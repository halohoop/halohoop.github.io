[{"title":"[饼干]如何获取官方的aar包","url":"http://halohoop.com/2017/10/05/cookies_how_to_get_aar/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ol>\n<li>怎么获取开源项目的aar包。</li>\n<li>support library的aar包又怎么获取呢。</li>\n</ol>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>首先我们来看看这个问题是如何产生的，因为公司需要配置Jenkins离线打包，而服务器为了避免编译的时候下载很多的未知的资源，以及编译节省时间，因此如果安卓的项目中如果在build.gradle中使用compile、api或者implementation引用开源项目的话，比如：</p>\n<pre><code>compile &apos;com.android.support:appcompat-v7:26.1.0&apos;\n</code></pre><p>如果服务器的sdk中没有下载有这个库，那么就很可能会导致离线编译不通过，因为专门用于编译工作的服务器有时候是没有必要连接外网的，没有外网就意味着不能够下载相关的引用的资源或者代码，因此我们通常会需要引用的开源项目的aar包，来支持离线编译。<br>然而通过compile、api或者implementation引用开源项目，我们在本地很可能会找不到aar，哪怕在build里面也找不到。<br>这个时候开头说的两个需求就来了。我们当然可以通过下载开源项目的源代码然后手动打aar包<a href=\"https://www.google.com.hk/search?safe=strict&amp;q=%E6%89%93aar%E5%8C%85&amp;oq=%E6%89%93aar%E5%8C%85&amp;gs_l=psy-ab.12..0i10i42k1.622035.622035.0.622425.1.1.0.0.0.0.264.264.2-1.1.0....0...1.1.64.psy-ab..0.1.262....0.MwxG2Y8zpJE\" target=\"_blank\" rel=\"external\">[谷歌一下]</a>的方式来得到，当然我们也可以通过官方的下载渠道得到。接下来就介绍一下如何获取官方的aar包。</p>\n<h2 id=\"获取官方的aar包\"><a href=\"#获取官方的aar包\" class=\"headerlink\" title=\"获取官方的aar包\"></a>获取官方的aar包</h2><h3 id=\"获取开源项目的aar包\"><a href=\"#获取开源项目的aar包\" class=\"headerlink\" title=\"获取开源项目的aar包\"></a>获取开源项目的aar包</h3><p>四个步骤，简单到怀疑人生</p>\n<ol>\n<li>打开链接<br><a href=\"https://search.maven.org/#search\" target=\"_blank\" rel=\"external\">https://search.maven.org/#search</a></li>\n<li>搜索开源项目名字<ul>\n<li>a. 比如搜索okhttp<br><img src=\"/2017/10/05/cookies_how_to_get_aar/5eb1829e-63d9-44cd-a217-3355d3f8cfe9.png\" alt=\"\"></li>\n</ul>\n</li>\n<li><p>下载</p>\n<ul>\n<li>a.这里需要说的一点就是，由于有些开源项目比如说squareup的okhttp，只是一个类库，也就是全部都是class文件，因此是不需要打包成aar包的，只需要一个jar包即可。</li>\n<li>b.点击对应开源项目的“jar”或者“aar”即可下载到对应版本的，如下图<br><img src=\"/2017/10/05/cookies_how_to_get_aar/b623fb45-dc06-42f3-bb6f-2a7a01c7ebfd.png\" alt=\"\"></li>\n<li><p>c.一般这个的版本都是最新发布的版本，如果不是想要的版本的时候，可以点击下图中的“all”，就能够得到所有的已发布的版本，这时候点击对应aar或者jar下载需要的包即可。<br><img src=\"/2017/10/05/cookies_how_to_get_aar/0ca1de32-e796-4991-9a05-0bf6082c67e9.png\" alt=\"\"><br><img src=\"/2017/10/05/cookies_how_to_get_aar/aad5e099-a4fc-41da-9f3e-3c24ab2491bb.png\" alt=\"\"></p>\n<h3 id=\"获取support-library的aar包\"><a href=\"#获取support-library的aar包\" class=\"headerlink\" title=\"获取support library的aar包\"></a>获取support library的aar包</h3></li>\n<li>比如需要找到appcompat-v7的25.3.1版本，去SDK下相应的文件夹下就能够找到了<ul>\n<li>[SDK_DIR]\\extras\\android\\m2repository\\com\\android\\support\\appcompat-v7\\25.3.1</li>\n</ul>\n</li>\n<li>如果不知道有什么版本怎么办，别怕，谷歌出品必属精品，肯定有迹可循的嘛<ul>\n<li>打开这个网址即可查看最近的和最新的发布的支持包版本了：<a href=\"https://developer.android.com/topic/libraries/support-library/revisions.html\" target=\"_blank\" rel=\"external\">Recent Support Library Revisions</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>引用</p>\n</li>\n</ol>\n<hr>\n<pre><code>//引用aar包配置\ndependencies {\n    //compile(name: &apos;xxx&apos;, ext: &apos;aar&apos;)\n    compile(name:&apos;mylib-release&apos;, ext:&apos;aar&apos;)\n}\nrepositories{\n    flatDir{\n        dirs &apos;libs&apos;\n    }\n}\n</code></pre><h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>如果想要更加深入拓展研究透彻，推荐可以从这些个方向去深入：</p>\n<ol>\n<li>如何打aar包。</li>\n<li>build.gradle中compile、api或者implementation回来依赖库在本地是以怎么样的形式存在的。<ul>\n<li>是一堆的资源文件和*.class文件还是什么？</li>\n<li>存在什么目录中？build文件夹中？</li>\n<li>难道不是compile引用一个库不是下载其aar包到本地么？</li>\n</ul>\n</li>\n</ol>\n","categories":["programming"],"tags":["cookies","android","maven","aar"]},{"title":"[点心]自定义控件之这文字有点浪-Kotlin实现","url":"http://halohoop.com/2017/08/08/snacks-wave_float_text_view/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>控件源码：<a href=\"https://github.com/halohoop/AndroidDigIn#24带文字的波浪\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/AndroidDigIn#24带文字的波浪</a></p>\n<h2 id=\"壹-效果图\"><a href=\"#壹-效果图\" class=\"headerlink\" title=\"壹.效果图\"></a>壹.效果图</h2><p><img src=\"/2017/08/08/snacks-wave_float_text_view/device-2017-07-13-004908.gif\" alt=\"demo0\"></p>\n<h2 id=\"贰-知识点\"><a href=\"#贰-知识点\" class=\"headerlink\" title=\"贰.知识点\"></a>贰.知识点</h2><ul>\n<li>1.SurfaceView子线程高效绘制；</li>\n<li>2.贝塞尔曲线画波浪；</li>\n<li>3.文字测量；</li>\n<li>4.Kotlin语法；</li>\n<li>5.Region+Path的使用；</li>\n</ul>\n<h2 id=\"叁-背景-amp-介绍\"><a href=\"#叁-背景-amp-介绍\" class=\"headerlink\" title=\"叁.背景&amp;介绍\"></a>叁.背景&amp;介绍</h2><ul>\n<li>给自己的需求是酱的：想要实现一个随着波浪浮动的文字。</li>\n<li>可能是因为使用kotlin语法简洁的缘故，代码只有不到400行。</li>\n<li>用工的孩子时间都不多，心照啦，所以全文会尽量不说废话或少说废话，先来一句废话，么么哒。</li>\n</ul>\n<h2 id=\"肆-使用方式\"><a href=\"#肆-使用方式\" class=\"headerlink\" title=\"肆.使用方式\"></a>肆.使用方式</h2><ul>\n<li>改变速度，绘制的时候就是根据速度的值来决定波浪移动的距离的，代码见下文的绘制方法</li>\n</ul>\n<hr>\n<pre><code>progress.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {\n    override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {\n        val value = progress.toFloat()\n        view.mSpeed = if (value&lt;=0) 1F else value\n    }\n\n    ...\n})\n</code></pre><hr>\n<ul>\n<li>修改文字，可以看到Kotlin的set我们只需要直接给变量赋值即可。</li>\n</ul>\n<hr>\n<pre><code>view实例.text = &quot;中abcdefghijkl文&quot;\n\n//具体的set、get方法\nvar text: String = &quot;Halohoop&quot;\n    set(value) {\n        stopLoopDraw()//先暂停\n        lock(lockObj,{\n            field = value\n            val textPosMidX = mMidX;\n            updateTextsConfigs(value, textPosMidX)\n        })\n        startLoopDraw()//重新开始\n    }\n    get\n</code></pre><hr>\n<h2 id=\"伍-拆解轮子\"><a href=\"#伍-拆解轮子\" class=\"headerlink\" title=\"伍.拆解轮子\"></a>伍.拆解轮子</h2><h3 id=\"1-绘制波浪。\"><a href=\"#1-绘制波浪。\" class=\"headerlink\" title=\"1.绘制波浪。\"></a>1.绘制波浪。</h3><ul>\n<li>准备波浪Path<ul>\n<li>如下图，不管你屏幕中画多少个周期，你给我<strong>画多一个周期</strong>出来用作移动就好了，每次朝一个方向移动完一个周期就重置。</li>\n<li><img src=\"/2017/08/08/snacks-wave_float_text_view/demo1.png\" alt=\"demo1\"></li>\n<li>取巧的方法是Path.rQuadTo方法，而不是直接用Path.quadTo，因为可以相对于上一个Path移动到的位置作为起点。</li>\n<li>看码</li>\n</ul>\n</li>\n</ul>\n<hr>\n<pre><code>private fun drawWave(canvas: Canvas?) {\n    paint.color = WAVE_COLOR\n    val quaterWaveWidth = mHalfWaveWidth / 2f;//四分之一个周期\n\n    path.rewind()//重置path，清空路径\n\n    val dx = mDx;//移动的距离\n    path.moveTo(0f - mHalfWaveWidth * 2f + dx, mMidY)//移动到开始点\n\n    for (i in 0..mWaveCount) {\n        path.rQuadTo(quaterWaveWidth, mWaveHeight, mHalfWaveWidth, 0f)\n        path.rQuadTo(quaterWaveWidth, -mWaveHeight, mHalfWaveWidth, 0f)\n    }\n\n    path.lineTo(measuredWidth.toFloat(), measuredHeight.toFloat())//和右下角连接起来\n    path.lineTo(0f, measuredHeight.toFloat())//和左下角连接起来\n    path.close()//封闭起来\n\n    canvas?.drawPath(path, paint)\n}\n</code></pre><hr>\n<h3 id=\"2-拆解文字，得到文字绘制的区域Rect。\"><a href=\"#2-拆解文字，得到文字绘制的区域Rect。\" class=\"headerlink\" title=\"2.拆解文字，得到文字绘制的区域Rect。\"></a>2.拆解文字，得到文字绘制的区域Rect。</h3><ul>\n<li>看码，你应该注意到方法中又定义方法，这是Kotlin特性，就是这么任性，抄抄JavaScript有时还抄抄C++抄抄Groovy…</li>\n<li>看码中注释即可，不废话</li>\n</ul>\n<hr>\n<pre><code>//用于计算文字位置的Region集合\nprivate var mTextPositionHelperRegions: ArrayList&lt;Region&gt;? = null\n//每个文字的宽度数组\nprivate lateinit var mEveryLetterWidths: FloatArray\n...\n@MainThread\nprivate fun updateTextsConfigs(newText: String, textPosMidX: Float) {\n\n    //获取每个文字的宽度\n    fun getEveryLetterWidth(text: String) : FloatArray{\n        mEveryLetterWidths = FloatArray(text.length)\n        textPaint.getTextWidths(text, 0, text.length, mEveryLetterWidths)\n        return mEveryLetterWidths\n    }\n\n    //得到所有文字的总宽\n    fun getHowWidthOfTexts(everyLetterWidths: FloatArray): Float {\n        mHowWidthOfTexts = 0f;\n        everyLetterWidths.forEach { mHowWidthOfTexts += it }\n        return mHowWidthOfTexts\n    }\n\n    //得到所有的文字的绘制区域，放入集合中\n    fun updateTextPositionHelperRegions(textPosMidX: Float = 0f, howWidthOfTexts: Float,\n                                                everyLetterWidths: FloatArray) {\n        val startX = textPosMidX - howWidthOfTexts / 2\n        val tmpEveryLetterWidths = everyLetterWidths\n        var tmpHowWidthOfTexts = howWidthOfTexts\n        val lettersCount = tmpEveryLetterWidths.size\n\n        if (mTextPositionHelperRegions != null) {\n            mTextPositionHelperRegions!!.clear()\n            mTextPositionHelperRegions = null\n        }\n        mTextPositionHelperRegions = ArrayList&lt;Region&gt;()\n\n        for (i in lettersCount - 1 downTo 0) {//倒序遍历每个字\n            if (tmpHowWidthOfTexts &lt; 0) tmpHowWidthOfTexts = 0f\n            tmpHowWidthOfTexts -= tmpEveryLetterWidths[i]\n            val region = Region((startX - 1 + tmpHowWidthOfTexts).toInt(), 0,\n                    (startX + tmpHowWidthOfTexts).toInt(), measuredHeight)\n            mTextPositionHelperRegions!!.add(0, region)//往最前面插\n        }\n    }\n\n    val everyLetterWidths = getEveryLetterWidth(newText)\n    //get how width of texts\n    val howWidthOfTexts = getHowWidthOfTexts(everyLetterWidths)\n    //initialize TextPositionHelperRegions\n    updateTextPositionHelperRegions(textPosMidX, howWidthOfTexts, everyLetterWidths)\n}\n</code></pre><hr>\n<h3 id=\"3-通过region得到波浪Path上的x，y坐标，将文字画出来。\"><a href=\"#3-通过region得到波浪Path上的x，y坐标，将文字画出来。\" class=\"headerlink\" title=\"3.通过region得到波浪Path上的x，y坐标，将文字画出来。\"></a>3.通过region得到波浪Path上的x，y坐标，将文字画出来。</h3><hr>\n<pre><code>private fun drawTexts(canvas: Canvas?) {\n    textPaint.color = TEXT_COLOR\n    var i = 0\n    val toCharArray = text!!.toCharArray()\n    mTextPositionHelperRegions?.forEach {\n        //以下这句是得到波浪上点的关键\n        //会往it,也就是mTextPositionHelperRegions的一个元素Region里面塞入裁剪之后的Rect\n        mRegion.setPath(path, it)//里面记录了Path和Region相交的四个方向的最值。\n        if (DEBUG) {\n            //debug\n            canvas?.drawRect(it.bounds, textPaint)\n        }\n\n        //使用左和上值绘制文字\n        canvas?.drawText(toCharArray[i] + &quot;&quot;, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat(), textPaint)\n        if (DEBUG &amp;&amp; i == 0) {\n            canvas?.drawText(text, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat() - 100, textPaint)\n        }\n        i++\n    }\n}\n</code></pre><hr>\n<h3 id=\"4-设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“-”拒绝kotlin帮你做好的空指针危险限制。\"><a href=\"#4-设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“-”拒绝kotlin帮你做好的空指针危险限制。\" class=\"headerlink\" title=\"4.设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“!!”拒绝kotlin帮你做好的空指针危险限制。\"></a>4.设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“!!”拒绝kotlin帮你做好的空指针危险限制。</h3><hr>\n<pre><code>fun startFlow() {\n    stopFlow()\n    flowAnimator = ValueAnimator.ofFloat(0f, mHalfWaveWidth * 2)\n            .setDuration(1000)\n    flowAnimator!!.setRepeatMode(ValueAnimator.RESTART)\n    flowAnimator!!.setRepeatCount(ValueAnimator.INFINITE)\n    flowAnimator!!.interpolator = LinearInterpolator()\n    flowAnimator!!.addUpdateListener {\n        mDx = it.animatedValue as Float\n        this@WaveWithTextView.invalidate(0, (mMidY - mWaveHeight).toInt(), measuredHeight, (mMidY + mWaveHeight).toInt())\n    }\n\n    flowAnimator!!.start()\n}\n\nfun stopFlow() {\n    if (flowAnimator != null &amp;&amp; flowAnimator!!.isRunning &amp;&amp; flowAnimator!!.isStarted) {\n        flowAnimator!!.cancel()\n        flowAnimator = null\n    }\n}\n</code></pre><hr>\n<h3 id=\"5-使用SurfaceView子线程绘制实现。\"><a href=\"#5-使用SurfaceView子线程绘制实现。\" class=\"headerlink\" title=\"5.使用SurfaceView子线程绘制实现。\"></a>5.使用SurfaceView子线程绘制实现。</h3><ul>\n<li>5.1.这里贴出关键绘制线程run方法代码：<ul>\n<li>其中是抽象方法onThreadRenderDraw，负责使用给的Canvas绘制工作，执行在子线程中.</li>\n<li>更多详情请参阅BaseSurfaceWaveWithTextsViewKotlin原码。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<pre><code>override fun run() {\n    val startTime = System.currentTimeMillis()\n    while (true) {\n        if (!mIsRunning) {//控制是否开始波浪起伏\n            Log.i(&quot;halohoop&quot;, &quot;Halohoop--&quot; + &quot;stop&quot;)\n            break\n        }\n        val canvas = mSurfaceHolder.lockCanvas()\n        if (canvas != null) {\n            lock(lockObj, {\n                if (mIsRunning) {\n                    onThreadRenderDraw(canvas, System.currentTimeMillis() - startTime)\n                }\n            })\n            //绘制完成\n            mSurfaceHolder.unlockCanvasAndPost(canvas)\n        }\n        try {\n            Thread.sleep(SLEEP_TIME)//用于保证和垂直刷新信号同步的时间差\n        } catch (e: InterruptedException) {\n            e.printStackTrace()\n        }\n    }\n}\n...\ncompanion object {\n    private val SLEEP_TIME: Long = 16//毫秒\n}\n...\n//其中onThreadRenderDraw是基类的抽象方法，\n//具体需要话什么需要子类自己去实现\n//并且这个方法是在子线程中进行绘制的。\n@WorkerThread\nprotected abstract fun onThreadRenderDraw(canvas: Canvas, l: Long)\n</code></pre><hr>\n<ul>\n<li>5.2.多线程加锁工具方法，由于涉及线程因此一些关键状态的修改需要加锁</li>\n</ul>\n<hr>\n<pre><code>fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T) {//为了加锁方便，定义了一个加锁工具方法\n    lock.lock()\n    try {\n        body()\n    }\n    finally {\n        lock.unlock()\n    }\n}\n...\n//使用示例\noverride fun surfaceDestroyed(holder: SurfaceHolder) {\n    lock(lockObj,{\n        stopLoopDraw()\n    })\n}\n</code></pre><hr>\n<ul>\n<li>5.3.具体的绘制过程</li>\n</ul>\n<hr>\n<pre><code>override fun onThreadRenderDraw(canvas: Canvas, l: Long) {\n    canvas.drawColor(Color.WHITE)\n\n    //当你单位时间水平方向的移动距离越大时候，速度就越快\n    mDx += mSpeed\n    if (mDx &gt;= mHalfWaveWidth * 2) {\n        mDx = 0f\n    }\n\n    if (DEBUG) {\n        canvas?.drawLine((measuredWidth shr 1).toFloat(), 0f,\n                (measuredWidth shr 1).toFloat(), measuredHeight.toFloat(), paint)\n    }\n\n    drawTexts(canvas)//画文字\n    drawWave(canvas)//画波浪\n\n}\n\n//没什么可说的，一目了然的命名\nprivate fun drawWave(canvas: Canvas?) {\n    paint.color = WAVE_COLOR\n    val quaterWaveWidth = mHalfWaveWidth / 2f;\n\n    path.rewind()//清空旧path\n\n    val dx = mDx;\n    path.moveTo(0f - mHalfWaveWidth * 2f + dx, mMidY)\n\n    for (i in 0..mWaveCount) {\n        path.rQuadTo(quaterWaveWidth, mWaveHeight, mHalfWaveWidth, 0f)\n        path.rQuadTo(quaterWaveWidth, -mWaveHeight, mHalfWaveWidth, 0f)\n    }\n\n    path.lineTo(measuredWidth.toFloat(), measuredHeight.toFloat())\n    path.lineTo(0f, measuredHeight.toFloat())\n    path.close()\n\n    canvas?.drawPath(path, paint)\n}\n\nprivate fun drawTexts(canvas: Canvas?) {\n    textPaint.color = TEXT_COLOR\n    var i = 0\n    val toCharArray = text!!.toCharArray()\n    mTextPositionHelperRegions?.forEach {\n        //kotlin的forEach遍历可以使用it来接收每一轮遍历的结果\n        mRegion.setPath(path, it)\n        //当一个Region和path相交的时候\n        //这个path在这个region中被用一个Rect来描述，也就是下面的bounds\n        //因此就能够得到这个path被region裁剪之后四边之最，左上右下\n        if (DEBUG) {\n            //debug\n            canvas?.drawRect(it.bounds, textPaint)\n        }\n\n        canvas?.drawText(toCharArray[i] + &quot;&quot;, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat(), textPaint)\n        if (DEBUG &amp;&amp; i == 0) {\n            canvas?.drawText(text, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat() - 100, textPaint)\n        }\n        i++\n    }\n}\n</code></pre><hr>\n<h2 id=\"陆-新需求迭代展望：\"><a href=\"#陆-新需求迭代展望：\" class=\"headerlink\" title=\"陆.新需求迭代展望：\"></a>陆.新需求迭代展望：</h2><ul>\n<li>1.支持使用图片替换文字。</li>\n<li>2.添加TextureView的版本，因为TextureView可以做view的动画。</li>\n<li>3.加入角度的旋转，打造文字随着波浪的切线摆动，会更加真实，欢迎继续关注。</li>\n</ul>\n<h2 id=\"柒-最后\"><a href=\"#柒-最后\" class=\"headerlink\" title=\"柒.最后\"></a>柒.最后</h2><p>声明：此控件没有经过完整测试，纯练手控件，不要随便在项目中使用，请自行完善。<br>思想为主，知识为辅，Coding随后。<br>如果读者还有不明朗的地方，欢迎查看源码，并且给我提bug，一起为这个社区做出自己的微薄贡献。</p>\n<p>控件源码：<a href=\"https://github.com/halohoop/AndroidDigIn#24带文字的波浪\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/AndroidDigIn#24带文字的波浪</a></p>\n","categories":["programming"],"tags":["android","effect","custom_view","snacks"]},{"title":"[露水]做技术，浮躁的人那么多，踏实的人那么少","url":"http://halohoop.com/2017/08/05/dewdrops-peace_in_your_heart/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>浮躁的人太多，加之网络键盘侠太多，动动手指，就能发泄自己的不满、自己的脾气，惯用自以为看清了一切的口气说话。</p>\n<p>天天忙的事情就是发现谁在装逼，然后自己又配合装逼来应和一下，在真实的世界实际的人际交往的时候或者相互认识的网络群中，这个举措或许会很有用，因为能够拉近彼此间的距离，但是彼此互相都不认识在网络世界的交流，一点用都没有的，至少我是这么认为的，如果说有那肯定也只是yy出来的有用罢了，所以说不要做这样的人，这样的人太浮躁，做技术就重要的就是真诚、落地和专注，而不是轻易的就被一件事情吸引，心生杂念。</p>\n<p>经常看见身边的或者是各种技术群里的人，看到一个人知道自己不知道的，就想要去做比较，想要比较这个和自己出现在同一个平台上的人是不是比自己学会的更多，想要知道到底他是怎么知道的，为什么会知道，久而久之，变成了“他怎么可能会比我还知道”，养成了容易心生嫉妒的习惯，嘴上称赞心理却很嫉妒，于是处处攀比，无法自拔，浮躁由此而生。</p>\n<p>细想，这可能是技术圈里很容易出现的一种情况，原因我想可能就是因为技术圈的快节奏以及高复杂度。<br>快节奏，只要你不是个无理想的富二代，那“不甘落后于别人”以及“危机感”就是你在这个社群中固有的属性，落后于是追赶，被追上于是加速，于是我们的圈子节奏越来越快。<br>高复杂度，就是说技术圈中技术成百上千，就拿计算机语言来说，榜上有名的<a href=\"https://www.tiobe.com/tiobe-index//programming-languages-definition/#instances\" target=\"_blank\" rel=\"external\">语言</a>就有200+种，每一种都是一个世界，这些世界或多或少的又可以相互沟通，每个人都会出现在这些大大小小世界中的某一片天空下，所以我享受的云彩可能在你的位置享受不到，反之亦然，因此出现“你了解的可能我不了解，我了解的可能你不了解”是很正常的。</p>\n<p>所以说网络上就出现了“程序员之间的鄙视链”.做技术的人不要总觉得比别人高人一等，不要觉得自己比别人聪明、比别人有优势，我觉得这是最没有用的，把姿态放的足够低，厚积薄发才是真正应该做的。</p>\n<p>再举个例子，有一句话是这么说的，“不能适应改需求的设计不是好设计”，不同的人对这句话的理解和体会可能会不一样，积极踏实的人，“哎！确实是这么回事，我要努力达到这个境界”，消极浮躁的人，“我艹，这肯定是产品说出来的话，不是程序猿说的”，你看，已相差甚远。只有积极踏实的人才能够真正从不好中发现美好和对自己的有意义的细节。</p>\n<p>我写这篇的目的不是为了说明自己做的有多么好，我只是觉得我很庆幸已经有这种觉悟并且觉得有义务分享出来罢了。</p>\n<p>————卖牙膏的芖口钉</p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[点心]Android Studio快捷键这篇就够了","url":"http://halohoop.com/2017/07/16/snacks_shortcuts_of_as/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"update-log\"><a href=\"#update-log\" class=\"headerlink\" title=\"update log\"></a>update log</h2><ul>\n<li>20170721 <ul>\n<li>+Esc取消选中</li>\n</ul>\n</li>\n<li>20170819<ul>\n<li>+选中方法的更加快捷的方式,Ctrl + W,搜索[方法选中]</li>\n<li>+用键盘键盘新建一个文件的更加快捷方式,Alt + insert,搜索[用键盘键盘新建一个文件的更加快捷方式]</li>\n</ul>\n</li>\n</ul>\n<p>##</p>\n<p><strong>将需要精确点击的事情，变得不需要精确，甚至是随机（有规则的随机，但是遵守这个规则是人的轻易就能做到的），让计算机来处理这种随机，那你的效率将会提高很多很多。</strong></p>\n<p><strong><em>————来自 卖牙膏霸气侧漏农村有文化的芖口钉（Halohoop）语录</em></strong></p>\n<p>(Yeah,I said that.😄)</p>\n<p>举个例子，一个界面窗口需要点击一个叉叉才能关闭，然后如果你能够使用一个手势，比如左滑或者右滑（有规律的随机，随便一个地方左/右滑动）来关闭这个窗口，那么效率就得到了提升，随之而来的也会是更好的用户体验，而快捷键和手势都是一种提效方式，废话不多说，接下来就来看我在AS中漂亮的回旋踢吧。</p>\n<p>文章可能是“关公面前耍大刀，包公面前晒太阳，老干妈面前吃辣条”，不是大佬的都共勉，是大佬的话就当笑话看吧，哇哈哈哈哈哈刀哈哈哈哈哈哈!!!</p>\n<p>另外，快捷键只有当你真正体会到它的方便之处，并且熟练操作了之后才能真正提高你的效率，如果觉得自己现在挺好的没什么必要的知道，可以跳过这个文章了哦，节省时间哇。.</p>\n<p>再另外，为了让读者有环环相扣的情景感，下文使用顶针的方式来写。并且涉及到代码的部分全都使用Kotlin。<br>（顶针的修辞手法：每段末尾和下一段开头呼应）</p>\n<hr>\n<p>本文快捷键基于windows版本AS，如果你已经修改过一些快捷键，本文的一些快捷键可能会失效。</p>\n<p>前面略显拖沓，故事现在从这里开始。</p>\n<h2 id=\"1-“Alt-F1，1（Alt-F1，直接再按1）”\"><a href=\"#1-“Alt-F1，1（Alt-F1，直接再按1）”\" class=\"headerlink\" title=\"1.“Alt + F1，1（Alt + F1，直接再按1）”\"></a>1.“Alt + F1，1（Alt + F1，直接再按1）”</h2><p>相信我们都会使用到这个按钮，“Scroll from Source”</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic1.png\" alt=\"图1\"></p>\n<p>可以帮我们找到正在编辑的文件所在项目的位置，在项目越来越复杂文件越来越多的时候是非常有用的，可是那么小的按钮，我真的不想再用鼠标去缓慢的<strong>精确定位</strong>再点击，显然这个问题巨人也遇到了，于是巨人给我们了一个“Alt + F1，1”。鼠标焦点在代码编辑界面的时候，“Alt + F1，1（Alt + F1，直接再按1）”。</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic2.png\" alt=\"图2\"></p>\n<p>可以发现这个Alt + F1之后弹出的窗口里面可不止这一个快捷键，比如，第8和第0都非常好用的咧。</p>\n<p>[用键盘键盘新建一个文件的更加快捷方式]<br>当我们焦点处于[1.Project]方法的时候，可以使用上下左右键将选中的项目定位在一个文件夹，然后按键盘“Alt + Insert”按键，就会有“Alt + F”的效果，但是弹出的菜单会更容易新建一个文件，去体会一下吧。</p>\n<p>好了，现在窗口的焦点到了[1.Project]这个模块中了，我们定位到了源文件的位置了，现在想要回到刚才代码焦点编辑的地方，显然我又想拒绝鼠标了，于是巨人给我们了一个“Esc”。</p>\n<p>鉴于下文也会用到“于是巨人给了我们一个”，因此定义如下：</p>\n<pre><code>val 于巨给个 = “于是巨人给了我们一个”//上帝说有光，那就有光了，哈哈哈\n</code></pre><hr>\n<h2 id=\"2-“Esc”\"><a href=\"#2-“Esc”\" class=\"headerlink\" title=\"2.“Esc”\"></a>2.“Esc”</h2><p>移动鼠标+点击的速度当然比不上我按一个Esc的速度，按下Esc，于是我们又回到了最初代码编辑的地方。<br>这个快捷键不仅在[1.Project]这个模块中是有用的，在很多界面你按Esc都是可以回到编辑窗口区域的，但是有些就不行，我知道的就是Terminal终端窗口中按Esc是回不去的，这个Terminal终端窗口下文也会提到。</p>\n<p>另外一个就是当你选中一堆代码的时候，你按“Esc”也会有取消选中的作用，这个稍微提一下就可以了。</p>\n<p>好了，既然回到代码区域，现在我们开始畅游代码世界，突然间，偶遇这一个代码段：</p>\n<pre><code>//来自android.view.ViewGroup#dispatchTouchEvent\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n        //此处省略200+行代码..\n        return handled;\n}\n</code></pre><p>相信只要不是竖屏的显示器都显示不全这个方法，必须要手动滚动鼠标才能看完，一般我们看源码想要加注释的话会将其拷贝出来到一个同名类中进行，拷贝这个动作则又是一个耗时操作，因为方法有200+行，需按着鼠标不松开，然后滚轮，于巨给个“Ctrl + Shift + ]”等。</p>\n<hr>\n<h2 id=\"3-“Ctrl-左或右”、“Ctrl-或-”-和-“Shift-上下左右“-以及它们的合体-“Ctrl-Shift-或-“和“Ctrl-Shift-左或右”\"><a href=\"#3-“Ctrl-左或右”、“Ctrl-或-”-和-“Shift-上下左右“-以及它们的合体-“Ctrl-Shift-或-“和“Ctrl-Shift-左或右”\" class=\"headerlink\" title=\"3.“Ctrl + 左或右”、“Ctrl + [ 或 ]” 和 “Shift + 上下左右“ 以及它们的合体 “Ctrl + Shift + [ 或 ]“和“Ctrl + Shift + 左或右”\"></a>3.“Ctrl + 左或右”、“Ctrl + [ 或 ]” 和 “Shift + 上下左右“ 以及它们的合体 “Ctrl + Shift + [ 或 ]“和“Ctrl + Shift + 左或右”</h2><p>说明这些个快捷键之前，我先定义几个点：</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic3.png\" alt=\"图3\"></p>\n<p>首先我们来解决上一小节的问题，快速复制整个方法，假设我们光标已经在第k行了，</p>\n<ul>\n<li>那么现在按home键，去到开头，也就是public的左边</li>\n<li>然后现在按Ctrl + Shift + ]，会发现从public到点b撇的位置都被选中了，然后我们再使用Shift + →，把最后的花括号选中，然后Ctrl + C那就大功告成了，别看这一段文字挺多的，熟练操作之后这个复制的操作应该只需要1秒。</li>\n<li>但是，这里要说明的是，并不是说鼠标就不好，只是知道键盘的操作可能会提高我们的效率罢了，单单看这个需求，可能鼠标会比我们更快也说不定，因为如果你在点a或者点a撇双击左键的话，点a到点a撇之间的内容就能够被选中了(点b和点b撇也是)。</li>\n<li>当然光标在点a或者点b的时候按“Ctrl + W”也是能够将方法选中的[方法选中]。</li>\n<li><p>但是如果要把上面的“@Override”也复制上，那就还是需要使用组合的快捷键比较好了。</p>\n<ul>\n<li>首先定位到k-1行；</li>\n<li>home到开头第一个字母；</li>\n<li>Shift + ↓选中k-1行，这时候光标在public开头；</li>\n<li>然后重复上文提到的步骤即可；</li>\n<li>文字虽长，但操作是瞬时的，重在体会快捷键设计的艺术；</li>\n</ul>\n</li>\n<li><p>“Ctrl + 左或右”：按词移动光标</p>\n</li>\n<li>“Ctrl + [ 或 ]”：寻找花括号及花括号的兄弟</li>\n<li>“Shift + 上下左右”：左右上下选中</li>\n<li>“Ctrl + Shift + [ 或 ]”：寻找花括号及花括号的兄弟 + 选中</li>\n<li>“Ctrl + Shift + 左右”：按词移动光标 + 选中</li>\n</ul>\n<p>很容易发现，加了Shift就有了选中功能，没加就是移动光标功能。</p>\n<p>好了，现在我们继续畅游ViewGroup#dispatchTouchEvent方法，使用<strong>“↑/↓方向键”</strong>一行行的过，使用<strong>“Ctrl + ↑/↓”</strong>一行行的滚动屏幕，突然间我们发现我们找到了onInterceptTouchEvent方法：</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic4.png\" alt=\"图4\"></p>\n<p>想要进去看看，然后想必我们下意识的操作肯定是，按住Ctrl，另一只手点击鼠标左键，虽然这个操作也很6，但是如果没有鼠标咧？于巨给个<strong>“F4”</strong>。</p>\n<hr>\n<h2 id=\"4-“F4”\"><a href=\"#4-“F4”\" class=\"headerlink\" title=\"4.“F4”\"></a>4.“F4”</h2><p>焦点在方法或者变量上的时候，按“F4”能够找到它们定义的位置。</p>\n<p>按“F4”，于是我们咻的一下去到了onInterceptTouchEvent的定义处：</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic5.png\" alt=\"图5\"></p>\n<p><strong><em>说到这里，我要重新提一下我开头的那句话儿了，上面包括下面会提到的快捷键无不例外的都遵循了我说的规律，那就是将需要手指精确定位或者人眼去找的部分去除掉，利用计算机的高速运算能力，比如说，“Ctrl + [”帮我们找到“}”的同组“{”在哪里，或者“Ctrl + F12”，匹配有相同关键字的方法，缩小肉眼观察的范围……等等.</em></strong></p>\n<p>好了回来，我们暂且不考虑onInterceptTouchEvent的if条件中更深的方法调用，所以这里就一个判断一眼扫过，onInterceptTouchEvent执行完就出栈了，这时候我们想要回到dispatchTouchEvent方法中继续看其下面的流程，dispatchTouchEvent和onInterceptTouchEvent隔了好几百行代码，我们可以通过<strong>“Ctrl + F12”</strong>然后输入dispatchTouchEvent前面几个字符，快速找回dispatchTouchEvent，但是还是太慢，因为还要肉眼去定位dispatchTouchEvent中调用onInterceptTouchEvent的位置，于巨给个<strong>“Ctrl + Alt + ←/→”</strong>。</p>\n<hr>\n<h2 id=\"5-“Ctrl-Alt-←-→”，光标位置的历史列表预览器\"><a href=\"#5-“Ctrl-Alt-←-→”，光标位置的历史列表预览器\" class=\"headerlink\" title=\"5.“Ctrl + Alt + ←/→”，光标位置的历史列表预览器\"></a>5.“Ctrl + Alt + ←/→”，光标位置的历史列表预览器</h2><p>我们按“Ctrl + Alt + ←”一下或者多下，按多下因为可能在找到onInterceptTouchEvent之后又按了鼠标好几下，如果每次点击位置都不一样，那么每次都会生成一个新历史位置数据，我想这个历史列表的Bean的数据结构很有可能是酱的：</p>\n<pre><code>data class CursorBean(var 什么文件: File, var 第几行: Int, var 第几列: Int)\n</code></pre><p>当然这个快捷键的按钮位置就在菜单工具栏，如下图：</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic6.png\" alt=\"图6\"></p>\n<p>当我们悬停在按钮上面的时候，就会发现它的快捷键被提示出来了，所以悬停肯定可以是我们获取快捷键的一条有效路径。</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic7.png\" alt=\"图7\"></p>\n<p>现在为了更加直观的看到dispatchTouchEvent和onInterceptTouchEvent以及onTouchEvent三个方法的执行顺序或者情况，我们想要在其中加log，因此我们需要新建一个ViewGroup类来进行，首选FrameLayout，用鼠标在对应包名右键新建或者是用鼠标点击File - New - Kotlin File/Class，都显得比较迟缓，或许你知道快捷键是“Alt + F，打开File菜单，然后使用上下左右键选择”，但是这个还是需要手动区定位，略显拖沓，于巨给个“Ctrl + Shift + A”。</p>\n<hr>\n<h2 id=\"6-“Ctrl-Shift-A”，通往全世界的任意门\"><a href=\"#6-“Ctrl-Shift-A”，通往全世界的任意门\" class=\"headerlink\" title=\"6.“Ctrl + Shift + A”，通往全世界的任意门\"></a>6.“Ctrl + Shift + A”，通往全世界的任意门</h2><p>想要新建一个Kotlin源代码文件MyFrameLayout.kt，只需按下“Ctrl + Shift + A”，然后输入模糊匹配的英文单词即可，比如说“new class”、“kotlinclass”等，然后你只需要在匹配出来的列表中选中“Kotlin File/Class”即可快速新建一个kt源代码文件了。</p>\n<p>实际情况中可能你还需要将这个新建的源代码文件放到新的包下，于是看我下面这一波操作：</p>\n<ul>\n<li>用上面讲过的“Scroll from Source”快捷键，“Alt + F1，1（Alt + F1然后再按1）”，定位到源代码文件；</li>\n<li>使用上下左右方向键定位到需要新建新包的包位置；<ul>\n<li>上下是切换到上下行，左右则是关闭和打开目录（如果是目录的话）；</li>\n</ul>\n</li>\n<li>这个时候按“Ctrl + Shift + A”，再输入“new packa”，这时候你可以看到“Directory/Package”出现了，直接回车，如果不是出现再第一个那就上下调整一下选中再回车。这时候输入想要新建的包名再回车即可。</li>\n<li>这时候会自动选中新建的包，这个时候再来“Ctrl + Shift + A”，输入“new class”或者“kotlinclass”随你便，接下去的事就和刚才新建包一样了。</li>\n<li>新建完MyFrameLayout.kt源文件，也会自动帮我们定位到编辑区的。</li>\n<li>敲入“class myfram”，根据提示完成补全即可，继承“FrameLayout”实现构造函数什么的我就不过多赘述了，都是“Alt + Enter”的事儿。</li>\n</ul>\n<p>“Ctrl + Shift + A”是通往全世界的任意门，除了上述的功能，输入任意的快捷键名字、菜单名字、窗口名字等，都能帮你列出来当成一条捷径。</p>\n<p>好现在我们的代码到了这一步：</p>\n<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr)\n</code></pre><p>这个时候很有可能我们的光标不在末尾，而是在这一行的某一个位置，如果你是用“Alt + Enter”辅助完成构造的编写的话，光标会在“FrameLayout”的位置，我们需要在末尾添加花括号对，于是我们先按“end”，然后…好麻烦哦。于巨给个“Ctrl + Shift + 回车”。</p>\n<hr>\n<h2 id=\"7-“Ctrl-Shift-回车”，自动补全代码\"><a href=\"#7-“Ctrl-Shift-回车”，自动补全代码\" class=\"headerlink\" title=\"7.“Ctrl + Shift + 回车”，自动补全代码\"></a>7.“Ctrl + Shift + 回车”，自动补全代码</h2><p>按下“Ctrl + Shift + 回车”之后会发现代码自动加上花括号了，并且光标定位到我们需要的位置了:</p>\n<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr) {\n    |←光标位置\n}\n</code></pre><p>不仅是这里的花括号，如果我们写的是java代码，这个快捷键还会帮我们补全补全末尾的分号，然后将光标自动移动到下一行的对齐的位置。</p>\n<p>然后现在我们挨个输入方法名的前几个字母根据提示重写上文中提到的dispatchTouchEvent和onInterceptTouchEvent以及onTouchEvent三个方法：</p>\n<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr) {\n    override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean {\n        return super.onInterceptTouchEvent(ev)\n    }\n\n    override fun onTouchEvent(event: MotionEvent?): Boolean {\n        return super.onTouchEvent(event)\n    }\n\n    override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {\n        return super.dispatchTouchEvent(ev)//这一行是被选中的状态，并且光标是在开头\n    }\n}\n</code></pre><p>这时候dispatchTouchEvent中的return语句整行应该是被选中状态的，并且光标处在开头，我们按一下“home”取消选中，让光标停留在“return”前面，现在我们想要直接往上面插入一行，于巨给个“Ctrl + 回车”。</p>\n<hr>\n<h2 id=\"8-“Ctrl-回车”，将光标处以后的代码移到下一行去，“Ctrl-Alt-回车”\"><a href=\"#8-“Ctrl-回车”，将光标处以后的代码移到下一行去，“Ctrl-Alt-回车”\" class=\"headerlink\" title=\"8.“Ctrl + 回车”，将光标处以后的代码移到下一行去，“Ctrl + Alt + 回车”\"></a>8.“Ctrl + 回车”，将光标处以后的代码移到下一行去，“Ctrl + Alt + 回车”</h2><p>现在单看dispatchTouchEvent方法，应该是这个样子的：</p>\n<pre><code>override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {\n    |←光标位置\n    return super.dispatchTouchEvent(ev)\n}\n</code></pre><p>另外我们还可以使用“Shift + 回车”，往下面插入一行，“Shift + 回车”支持光标不在行末尾就能够快速向下插入新的一行，这个我相信很多人知道啦。</p>\n<p>当然有下必有上，为了能够快速向上插入新的一行，于巨给个“Ctrl + Alt + 回车”，那么我们其实从开头就可以使用这个快捷键，而不需要按一下“home”取消选中了。</p>\n<p>现在我们将log打印代码加好，现在得到如下：</p>\n<p>Commons.kt：</p>\n<pre><code>val TAG = &quot;Halohoop&quot;\n\ninline fun String.logMe(filter: String = &quot;&quot;) {\n        Log.i(TAG, TAG + &quot;--&quot; + filter + toString())\n}\n</code></pre><p>MyFrameLayout.kt：</p>\n<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr) {\n    override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean {\n        &quot;onInterceptTouchEvent&quot;.logMe()\n        return super.onInterceptTouchEvent(ev)\n    }\n\n    override fun onTouchEvent(event: MotionEvent?): Boolean {\n        &quot;onTouchEvent&quot;.logMe()\n        return super.onTouchEvent(event)\n    }\n\n    override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {\n        &quot;dispatchTouchEvent&quot;.logMe()\n        return super.dispatchTouchEvent(ev)\n    }\n}\n</code></pre><p>现在突然我发现我想要加个过滤字符串“–Road1–”，好让我们在monitor中看的更清楚，当然我们可以打好，然后复制挨个粘贴过去。但是这里我要介绍一个比较好用的功能，IntelliJ IDEA的多光标功能功能，鼠标点击第一个光标需要去到的位置，然后现在按着“Alt + Shift”不放开，用鼠标点击其他的光标位置：</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic8.gif\" alt=\"图8\"></p>\n<p>现在我们想要研究一下onInterceptTouchEvent的相关流程，于是我们又覆盖这个方法：</p>\n<pre><code>override fun requestDisallowInterceptTouchEvent(disallowIntercept: Boolean) {\n    &quot;requestDisallowInterceptTouchEvent&quot;.logMe()\n    super.requestDisallowInterceptTouchEvent(disallowIntercept)\n}\n</code></pre><p>当我们写的方法越来越多的时候，不考虑使用鼠标的情况下，想在类中肆意的穿梭，我们使用键盘的上下所有键一行行一个个字母，略显笨拙，于巨给个“好几个快捷键呢，请看下节”。</p>\n<hr>\n<h2 id=\"9-“Alt-上下”：成员变量之间穿梭，“Ctrl-F12”：模糊匹配查找成员，“Ctrl-F11、F11、Shift-F11”：书签功能\"><a href=\"#9-“Alt-上下”：成员变量之间穿梭，“Ctrl-F12”：模糊匹配查找成员，“Ctrl-F11、F11、Shift-F11”：书签功能\" class=\"headerlink\" title=\"9.“Alt + 上下”：成员变量之间穿梭，“Ctrl + F12”：模糊匹配查找成员，“Ctrl + F11、F11、Shift + F11”：书签功能\"></a>9.“Alt + 上下”：成员变量之间穿梭，“Ctrl + F12”：模糊匹配查找成员，“Ctrl + F11、F11、Shift + F11”：书签功能</h2><p>一般这些快捷键都是穿插着使用的，这里不好用语言描述，读者可以去试试，“Ctrl + F12”相信大家都知道，就像Eclipse中的“Ctrl + O”。</p>\n<p>不过我要特别说一下这个书签功能，“F11”是给当前行加一个书签，按下之后你会看到在平时你打断点的位置旁边会出现一个对勾；那么除了对勾之外还可以使用“Ctrl + F11”选择“0-9和A-Z”其中一个标记作为当前标签，按键盘对应英文字母即可，这个时候对勾被换成了对应的字母。然后我们可以使用“Shift + F11”将打开书签列表，可以进行书签的更改，当然直接在当前行按“F11”取消书签也是可以的。</p>\n<p>书签这个功能很实用，提供“0-9和A-Z”的书签目的是什么，读者可以站在IDE设计者的角度揣摩一下，为了方便开发者看代码，这个书签设计很棒棒，我个人常常使用这个作为标记以及跟踪源码的这个调用链，在单单就某一块知识（比如说事件分发）进行研究的时候，10+26个书签应该是非常非常够用的了。</p>\n<p>好了现在再回到我们的场景中，假设现在我们已经为我们的MyFrameLayout类加了非常多的log信息了，我们定义的String的内联方法“logMe()”在太多地方调用到了，我们需要删除一些，我们通常的做法可能是这样，在logMe的定义处，按着“Ctrl”然后点击鼠标左键就会出现调用“logMe()”的代码行列表了，不用鼠标怎么操作，于巨给个“Ctrl + Alt + F7”。</p>\n<hr>\n<h2 id=\"10-“Ctrl-Alt-F7”、“Alt-F7”\"><a href=\"#10-“Ctrl-Alt-F7”、“Alt-F7”\" class=\"headerlink\" title=\"10.“Ctrl + Alt + F7”、“Alt + F7”\"></a>10.“Ctrl + Alt + F7”、“Alt + F7”</h2><p>使用“Shift,Shift”找到我们的“Commons.kt”文件，我们用“Ctrl + F12”，把光标移动到“logMe”这个方法名字上，然后“Ctrl + Alt + F7”，就能得到和“Ctrl+点击鼠标左键”一样的功能咯。当然还有一个快捷键就是“Alt + F7”，不过这个不是以弹出窗的形式，而是打开[3:Find]模块窗口，这个窗口在我们使用“Ctrl + Shift + R”全局字符串替换 或者“Ctrl + Shift + F”全局字符串搜索的时候也会使用到。</p>\n<p>假设现在我们已经从源码中的得到了我们想要的知识了，正式进入开发阶段，为了开发方便，我现在想引入一个Kotlin官方提供的<a href=\"https://github.com/Kotlin/anko\" target=\"_blank\" rel=\"external\">anko</a>裤，于是使用“Shift,Shift”找到我们module的“build.gradle”文件，拷贝对应的字符串：</p>\n<pre><code>compile &quot;org.jetbrains.anko:anko:$anko_version&quot;\n</code></pre><p>使用“Ctrl + F”，输入“depende”定位到dependencies的DSL块(在gradle中还不支持“Ctrl + F12”)，使用上文提过的“Ctrl + ]”定位到末尾的花括号“}”，在使用上文提过的“Ctrl + Alt + 回车”向上插入一行，然后粘贴即可。还是那句话，描述虽长，熟练操作后是瞬间的事，这里不去比较使用鼠标是否更好，本文只专注介绍快捷键。</p>\n<p>因为我们修改了gradle文件，所以“Sync Now”那条黄色背景的提示会出现tabs的下面，我们可以移动鼠标去点击，然而我这里又告诉你，没有快捷键，当然成熟的IDE怎么可能就此妥协，于巨给个“定制快捷键功能”。</p>\n<hr>\n<h2 id=\"11-定制“Gradle-Sync”快捷键，个人推荐“Alt-C-Alt-C”\"><a href=\"#11-定制“Gradle-Sync”快捷键，个人推荐“Alt-C-Alt-C”\" class=\"headerlink\" title=\"11.定制“Gradle Sync”快捷键，个人推荐“Alt + C,Alt + C”\"></a>11.定制“Gradle Sync”快捷键，个人推荐“Alt + C,Alt + C”</h2><p>打开设置，直接上图，一目了然。</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic9.png\" alt=\"图9\"></p>\n<p>个人推荐设置成连续按两次“Alt + C”，也就是“Alt + C,Alt + C”。按“Esc”关闭设置，然后“Alt + C,Alt + C”，发现“Gradle Sync”执行了。</p>\n<p>这时候我们想要将这个gralde的tab关闭，我们可能会点击tab的×，或者之间在tab上点击中键，但是其实我们可以省略了手从键盘移动到鼠标上的步骤，而直接在键盘上操作。</p>\n<hr>\n<h2 id=\"12-关闭tab，关闭其他tabs\"><a href=\"#12-关闭tab，关闭其他tabs\" class=\"headerlink\" title=\"12.关闭tab，关闭其他tabs\"></a>12.关闭tab，关闭其他tabs</h2><p>因为默认的关闭tab的快捷键还涉及到要按“F4”的组合，我觉得操作起来不太方便，而且开关tab是个很常用的操作，因此我个人推荐设置成“Ctrl  + Shift + Q”，原因如下：原来我还以为这个关闭tab的快捷键会和Chrome浏览器一样是“Ctrl + W”，结果发现AS的“Ctrl + W”是另一个很好用的功能，那就是扩展选中，为了避免冲突，再三考虑之后“close tab”就设置成“Ctrl  + Shift + Q”了，于是“close others”就设置成“Alt + Shift + Q”了。和在Settings的keymap中搜索“tab”，还能找到其他的快捷键，读者可自行查看。</p>\n<p>上面提到了“Ctrl + W”，用法的例子如下：</p>\n<p>比如现在有一个字符串“Halohoop”，光标停在了“Ha”之后“lohoop”之前，“Ha↑lohoop”，如果我们要选中这个单词可以直接按“Ctrl + W”，读者实操一下就能上手了，还可以试一下多按几次“Ctrl + W”看看有什么效果。</p>\n<p>好了，回到场景中，现在我想要挨个过一下打开的tabs，以决定要不要关闭它，于巨给个“Alt + 左或右”。</p>\n<hr>\n<h2 id=\"13-“Alt-左或右”\"><a href=\"#13-“Alt-左或右”\" class=\"headerlink\" title=\"13.“Alt + 左或右”\"></a>13.“Alt + 左或右”</h2><p>我们切换tab不需要鼠标去点，“Alt + 左或右”即可。这个快捷键不仅在Editoer窗口中可以使用，在[1:Project](“Alt + 1”)或者[6:Android Monitor](“Alt + 6”)也可以使用。</p>\n<p>文章到尾声了，还有一些有用的快捷键我就不套用情景去说了，在这里直接提一下。</p>\n<hr>\n<h2 id=\"14-“Ctrl-上或下”，“Ctrl-Alt-Shift-左或右”，滚动编辑区域的单行或者单字母\"><a href=\"#14-“Ctrl-上或下”，“Ctrl-Alt-Shift-左或右”，滚动编辑区域的单行或者单字母\" class=\"headerlink\" title=\"14.“Ctrl + 上或下”，“Ctrl + Alt + Shift + 左或右”，滚动编辑区域的单行或者单字母\"></a>14.“Ctrl + 上或下”，“Ctrl + Alt + Shift + 左或右”，滚动编辑区域的单行或者单字母</h2><p>有时候我们使用鼠标滚轮可能不能很好的精确控制滚到某一行，所以可以使用滚轮，滚到附近的时候再使用“Ctrl + 上或下”。<br>左右的滚动也是，拖动可能不能很好的精确控制滚到某一列，使用“Ctrl + Alt + Shift + 左或右”。</p>\n<hr>\n<h2 id=\"15-Shift-F6，关联重命名，不用解释。\"><a href=\"#15-Shift-F6，关联重命名，不用解释。\" class=\"headerlink\" title=\"15.Shift + F6，关联重命名，不用解释。\"></a>15.Shift + F6，关联重命名，不用解释。</h2><hr>\n<h2 id=\"16-Alt-F12-打开-关闭终端Terminal\"><a href=\"#16-Alt-F12-打开-关闭终端Terminal\" class=\"headerlink\" title=\"16.Alt + F12 打开/关闭终端Terminal\"></a>16.Alt + F12 打开/关闭终端Terminal</h2><hr>\n<h2 id=\"17-知道快捷键，但是想查找功能的名字\"><a href=\"#17-知道快捷键，但是想查找功能的名字\" class=\"headerlink\" title=\"17.知道快捷键，但是想查找功能的名字\"></a>17.知道快捷键，但是想查找功能的名字</h2><p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic10.png\" alt=\"图10\"></p>\n<hr>\n<h2 id=\"18-鼠标中键滚轮按着不放可以垂直选中\"><a href=\"#18-鼠标中键滚轮按着不放可以垂直选中\" class=\"headerlink\" title=\"18.鼠标中键滚轮按着不放可以垂直选中\"></a>18.鼠标中键滚轮按着不放可以垂直选中</h2><p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic11.gif\" alt=\"图11\"></p>\n<p>这个功能“Sublime”也有。其实和第8节中上中提到的多光标功能应该属于一套。</p>\n<hr>\n<h2 id=\"19-导出设置\"><a href=\"#19-导出设置\" class=\"headerlink\" title=\"19.导出设置\"></a>19.导出设置</h2><p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic12.png\" alt=\"图12\"></p>\n<p>换电脑或者重装系统的时候记得导出设置，这样自定义的快捷键就不会丢失了。</p>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>因为AS基于IntelliJ IDAE，所以以上快捷键也基本适用于IntelliJ IDAE的其他变种，如WebStorm、PyCharm等。</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic13.png\" alt=\"图13\"></p>\n<p>当然鼠标也是很重要很重要的，我们的眼神已经习惯跟着鼠标来回移动，鼠标能够帮我们更加集中我们的目光和注意力，也是必不可少的，毕竟不可能只用到IDE而已，IDE以外的软件不可能全部离开鼠标，而且IDE中所有功能也并非使用键盘就能全部完成了，比如说精确调整[6:Android Monitor](“Alt + 6”)的高度，虽然也有快捷键，但是是按单位高度调整的。</p>\n<p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic14.png\" alt=\"图14\"></p>\n<p>记录这篇文章的目的，一是希望真的能够帮助到彼此提高效率，二是想好好玩味一下IDE的设计者为开发者到底能考虑到多么方便的程度，我想现在我内心应该已经有了答案了。</p>\n<p>如果以后还有什么更好用的快捷键功能我也会更新到这篇博文的。</p>\n<h3 id=\"1-文章提到的快捷键预览表\"><a href=\"#1-文章提到的快捷键预览表\" class=\"headerlink\" title=\"1.文章提到的快捷键预览表\"></a>1.文章提到的快捷键预览表</h3><p>这里我不写作用，看看用以回顾，看看能反应出来多少个.</p>\n<ul>\n<li>1.Alt + F1,1</li>\n<li>2.Alt + F1,0</li>\n<li>3.Alt + F1,8</li>\n<li>4.Esc</li>\n<li>5.Ctrl + 左或右</li>\n<li>6.Ctrl + [ 或 ]</li>\n<li>7.Shift + 上下左右</li>\n<li>8.Ctrl + Shift + [ 或 ]</li>\n<li>9.Ctrl + Shift + 左或右</li>\n<li>10.F4</li>\n<li>11.Ctrl + Alt + 左或右</li>\n<li>12.Ctrl + Shift + A</li>\n<li>13.Alt + Enter</li>\n<li>14.Ctrl + Shift + 回车</li>\n<li>15.Ctrl + 回车</li>\n<li>16.Ctrl + Alt + 回车</li>\n<li>17.Shift + 回车</li>\n<li>18.Alt + Shift不放开，鼠标点击其他位置</li>\n<li>19.Alt + 上下</li>\n<li>20.Ctrl + F12</li>\n<li>21.Ctrl + F11</li>\n<li>22.F11</li>\n<li>23.Shift + F11</li>\n<li>24.Ctrl + Alt + F7</li>\n<li>25.Alt + F7</li>\n<li>26.Ctrl + Shift + R</li>\n<li>27.Ctrl + Shift + F</li>\n<li>28.Ctrl + F</li>\n<li>29.Gradle Sync</li>\n<li>30.关闭tab，关闭其他tabs</li>\n<li>31.Ctrl + W</li>\n<li>32.Alt + 左或右</li>\n<li>33.Ctrl + 上或下</li>\n<li>34.Ctrl + Alt + Shift + 左或右</li>\n<li>35.Shift + F6</li>\n<li>36.鼠标中键滚轮按着不放</li>\n</ul>\n<h3 id=\"2-找快捷键：\"><a href=\"#2-找快捷键：\" class=\"headerlink\" title=\"2.找快捷键：\"></a>2.找快捷键：</h3><ul>\n<li>1.Settings的Keymap中搜索关键字；</li>\n<li>2.“Ctrl + Shift + A”搜索关键字；</li>\n<li>2.鼠标悬停的提示中；</li>\n<li>3.右键菜单中；</li>\n</ul>\n<h3 id=\"3-其他的提效方式——手势\"><a href=\"#3-其他的提效方式——手势\" class=\"headerlink\" title=\"3.其他的提效方式——手势\"></a>3.其他的提效方式——手势</h3><p>如开头提到的，快捷键和手势都是一种提效方式，接下来也提一下手势。<br>其实，不仅仅是手机，在MAC，PC，浏览器，无不例外的出现了Gesture插件。</p>\n<p>因为这不是本文重点，所以这里我只列举一些我自己平常在PC端用到软件或插件：</p>\n<h4 id=\"3-1-PC-端：StrokeIt。\"><a href=\"#3-1-PC-端：StrokeIt。\" class=\"headerlink\" title=\"3.1.PC 端：StrokeIt。\"></a>3.1.PC 端：StrokeIt。</h4><p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic15.png\" alt=\"图15\"></p>\n<p>这个真的很好用，还是开源的软件，一年前，为了表示支持，我还把我PayPal赚到的10多美元全部Donate给他了。<br>地址：<a href=\"http://www.tcbmi.com/strokeit/\" target=\"_blank\" rel=\"external\">http://www.tcbmi.com/strokeit/</a></p>\n<h4 id=\"3-2-热键小工具-myhotkey\"><a href=\"#3-2-热键小工具-myhotkey\" class=\"headerlink\" title=\"3.2.热键小工具(myhotkey)\"></a>3.2.热键小工具(myhotkey)</h4><pre><code>* [热键助手 v4.6.0 正式版](http://www.crsky.com/soft/2159.html)\n* 支持设置热键打开各种软件、文件、文件夹，告别混乱的桌面快捷方式。 \n</code></pre><h4 id=\"3-3-FireFox：\"><a href=\"#3-3-FireFox：\" class=\"headerlink\" title=\"3.3.FireFox：\"></a>3.3.FireFox：</h4><p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic16.png\" alt=\"图16\"></p>\n<h4 id=\"3-4-Chrome：\"><a href=\"#3-4-Chrome：\" class=\"headerlink\" title=\"3.4.Chrome：\"></a>3.4.Chrome：</h4><p><img src=\"/2017/07/16/snacks_shortcuts_of_as/pic17.png\" alt=\"图17\"></p>\n<h4 id=\"3-5-MAC\"><a href=\"#3-5-MAC\" class=\"headerlink\" title=\"3.5.MAC\"></a>3.5.MAC</h4><p>MAC显然是天生自带这些插件的功能的，天生丽质，对于我这种一个月只有几十毛捡破烂钱收入的人来说只能是一笑而过，诶。</p>\n<hr>\n<p>最后，总而言之，言而总之（知难而退，退避三舍，舍近求远，远走高飞，飞檐走壁去去就来…突然很想成语接龙），快捷键就像女友，一直都在那里，只是你不去找而已，当然，像我这种颜值负数的人来说就另当别论了。</p>\n<p>最最后，自强，共勉，卖牙膏霸气侧漏农村有文化的芖口钉 敬上。</p>\n","categories":["programming"],"tags":["android","snacks","shortcuts"]},{"title":"[露水]使用计算机的时候提升效率的本质","url":"http://halohoop.com/2017/07/14/the_key_to_efficiency/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>将需要精确点击的事情，变得不需要精确，甚至是随机（有规则的随机，但是遵守这个规则是人轻易就能做到的），让计算机来处理这种随机，那你的效率将会提高很多很多。 </p>\n<p>————来自 卖牙膏霸气侧漏农村有文化的芖口钉（Halohoop）语录</p>\n<p>那么你可能需要这些工具：</p>\n<ul>\n<li><p>PC 端：StrokeIt。</p>\n<ul>\n<li><p>地址：<a href=\"http://www.tcbmi.com/strokeit/\" target=\"_blank\" rel=\"external\">http://www.tcbmi.com/strokeit/</a></p>\n<p><img src=\"/2017/07/14/the_key_to_efficiency/demo0.png\" alt=\"demo0\"></p>\n</li>\n</ul>\n<p>这个真的很好用，还是开源的软件，一年前，为了表示支持，我还把我PayPal赚到的10多美元全部Donate给他了。</p>\n</li>\n<li><p>热键小工具(myhotkey)</p>\n<ul>\n<li><a href=\"http://www.crsky.com/soft/2159.html\" target=\"_blank\" rel=\"external\">热键助手 v4.6.0 正式版</a></li>\n<li>支持设置热键打开各种软件、文件、文件夹，告别混乱的桌面快捷方式。 </li>\n</ul>\n</li>\n<li><p>FireFox插件：FireGestures</p>\n<p>  <img src=\"/2017/07/14/the_key_to_efficiency/demo1.png\" alt=\"demo1\"></p>\n</li>\n<li><p>Chrome插件：Gestures for google Chrome</p>\n<p>  <img src=\"/2017/07/14/the_key_to_efficiency/demo2.png\" alt=\"demo2\"></p>\n<ul>\n<li>如果StrokeIt和上述两者同时使用想必会冲突，那么StrokeIt可以支持设置开启什么软件的时候自动失效；</li>\n<li>所以玩游戏的时候也需要失效，或者玩游戏的时候直接关闭，不然你会发现游戏里面鼠标右键可能会莫名奇效失效；</li>\n</ul>\n</li>\n<li><p>Everything或者Listrary：</p>\n<ul>\n<li>Everything地址：<a href=\"http://www.voidtools.com/\" target=\"_blank\" rel=\"external\">http://www.voidtools.com/</a></li>\n<li><p>Listrary地址：<a href=\"http://www.voidtools.com/\" target=\"_blank\" rel=\"external\">http://www.listary.com/</a></p>\n<p><img src=\"/2017/07/14/the_key_to_efficiency/demo3.png\" alt=\"demo3\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>注意我用的是“或者”，因为这两个软件基本功能是一致的。</p>\n<p>支持正则表达搜索PC中文件，个人偏向使用Everything，一来因为Listrary使用的时候会侵入你的打开文件夹的界面使用流程，二来Listrary高级功能需要收费，个人觉得Everything还是比较简单的。</p>\n<p>比如我想要搜索一个你电脑中忘记存在哪里了的文件，名字是“苍井空大战哥斯拉之他好我也好.avi”，我只能依稀记得名字有“苍井空”、“哥斯拉”、“好”,那我就在Everything的窗口输入”苍井空”(不包括引号)，结果我发现苍井空毕生绝版都在电脑中，实在太多了，没有一眼看到我要的“苍井空大战哥斯拉之他好我也好.avi”，于是继续完善输入，”苍井空.*哥斯拉.*好”(不包括引号,这里的”.*”就表示匹配任意多个字符)，这个时候我要的文件就出现在我的面前了，然后就可以…开始播放了。</p>\n<ul>\n<li>显然，MAC是自带这些插件的功能的，对于我这种一个月只有几十毛捡破烂钱收入的人来说只能是一笑而过，诶。</li>\n</ul>\n<p>我这里就不再造轮子教程教大家怎么用了，网上就有很多很多的使用和设置的教程。</p>\n<p>你只需要</p>\n<p><strong><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"external\">百度一下</a></strong> </p>\n<p>或者 </p>\n<p><strong><a href=\"https://www.google.com\" target=\"_blank\" rel=\"external\">Google手气不错</a></strong>  就可以了。</p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[大餐]写个Kotlin+MVP+Retrofit2+RxJava2+Daggers2的示例代码","url":"http://halohoop.com/2017/06/27/meals-kotlin_mvp_retrofit2_rxjava2_dagger2_demo/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"源码：\"><a href=\"#源码：\" class=\"headerlink\" title=\"源码：\"></a>源码：</h2><p><strong><a href=\"https://github.com/halohoop/Kotlin_Mvp_R2R2D2\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/Kotlin_Mvp_R2R2D2</a></strong></p>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><img src=\"/2017/06/27/meals-kotlin_mvp_retrofit2_rxjava2_dagger2_demo/demo0.gif\" alt=\"demo0\"></p>\n<ul>\n<li>try<br><a href=\"https://github.com/halohoop/Kotlin_Mvp_R2R2D2/releases/download/v1.0/app-release_v1.0.apk\" target=\"_blank\" rel=\"external\">Donwload APK</a></li>\n</ul>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><strong>Demo的功能是显示，自己的Github 和 大神的Github 之间相差多少个Followers.</strong></li>\n<li><p>三个接口:</p>\n<ul>\n<li>1.<del><a href=\"https://api.github.com/search/users?q={id}\" target=\"_blank\" rel=\"external\">https://api.github.com/search/users?q={id}</a></del></li>\n<li>2.<a href=\"http://halohoop.com/halohoop_custom_datas/meals-kotlin_mvp_retrofit2_rxjava2_dagger2_demo/user1.json\">http://halohoop.com/halohoop_custom_datas/meals-kotlin_mvp_retrofit2_rxjava2_dagger2_demo/user1.json</a></li>\n<li>3.<a href=\"https://api.github.com/users/{id}\" target=\"_blank\" rel=\"external\">https://api.github.com/users/{id}</a></li>\n</ul>\n</li>\n<li><p>使用Retrofit2请求上述api；</p>\n</li>\n<li>使用Dagger2注入对象；</li>\n<li>整体架构使用MVP；</li>\n<li>P层使用RxJava2辅助过度连接M层和V层；</li>\n</ul>\n<h2 id=\"Use-Android-Studio-Version\"><a href=\"#Use-Android-Studio-Version\" class=\"headerlink\" title=\"Use Android Studio Version\"></a>Use Android Studio Version</h2><ul>\n<li>3.0 Canary 4</li>\n</ul>\n<h2 id=\"Thanks-for\"><a href=\"#Thanks-for\" class=\"headerlink\" title=\"Thanks for\"></a>Thanks for</h2><ul>\n<li><a href=\"https://github.com/grantland/android-autofittextview\" target=\"_blank\" rel=\"external\">https://github.com/grantland/android-autofittextview</a></li>\n<li><a href=\"https://github.com/robinhood/ticker\" target=\"_blank\" rel=\"external\">https://github.com/robinhood/ticker</a></li>\n</ul>\n","categories":["programming"],"tags":["android","kotlin","meals","MVP","Retrofit2","RxJava2","Daggers2"]},{"title":"[饼干]ViewPager配套滑动回调onPageScrolled","url":"http://halohoop.com/2017/06/24/cookies-android_vp_onpagescrolled/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>ViewPager配套滑动回调ViewPager.OnPageChangeListener有三个方法：</p>\n<pre><code>void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);\nvoid onPageSelected(int position);\nvoid onPageScrollStateChanged(int state);\n</code></pre><p>不用过多解释，是人都会用，但是有一个方法比较复杂，三个参数的onPageScrolled，每次使用都要打印着看看到底这三个参数到底是什么，有什么规律。</p>\n<p><strong>在这里，将这三个参数在这里做一个一目了然的阐述，以便下一次再用的时候直接上手，节省时间。</strong></p>\n<ul>\n<li>首先，这个方法是在手指滑动的时候不断会回调的，和move事件一样，参数1最复杂，我们放到最后讲。</li>\n<li>参数2：positionOffset：<ul>\n<li>取值范围是[0, 1).</li>\n<li>手指右滑（包括释放手指后的同一个趋势的运动），数值变化范围(1→0]，越来越小，最后一次回调给你一个0。</li>\n<li>手指左滑（包括释放手指后的同一个趋势的运动），数值变化范围[0→1)，越来越大，但是<strong>最后一次回调也给你一个0</strong>，也就是到0.99..之后就变回0。</li>\n</ul>\n</li>\n<li>参数3：positionOffsetPixels：<ul>\n<li>和positionOffset套路完全一样，只是数值换成了像素，要注意手指左滑最后的从最大变回0的细节.</li>\n</ul>\n</li>\n<li><p>参数1：position，有点复杂的规则：</p>\n<ul>\n<li>滑动的时候，一般可见的是两页，那么这个参数就是给你第一个可见的页面.<ul>\n<li>比如，如果当前处于第1页，前面还有第0页，后面有第2页，像这样[0,<strong>1</strong>,2…]:<ul>\n<li>手指右滑，那么position会一直给你0，最后一次回调给你0，因为滑动的时候可见的是0和1，滑动完成后可见的是0.</li>\n<li>手指左滑，那么position会一直给你1，最后一次回调给你2，因为滑动的时候可见的是1和2，滑动完成后可见的是2.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>源码中的注释还有一段描述如下：<ul>\n<li>“Page position+1 will be visible if positionOffset is nonzero”,综合上面描述，我们也能发现这个规律，也就是当可见positionOffset不为0的时候，position+1的页面是可见的，可能处于滑动（或者释放手指后的滑动）中。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Stay hungry stay foolish!</p>\n</li>\n</ul>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n","categories":["programming"],"tags":["cookies","view","android","ViewPager"]},{"title":"[点心]ViewPager动画类库原码解析","url":"http://halohoop.com/2017/06/24/snacks-vp_anima_detail/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h1 id=\"ViewPager动画类库原码解析\"><a href=\"#ViewPager动画类库原码解析\" class=\"headerlink\" title=\"ViewPager动画类库原码解析\"></a>ViewPager动画类库原码解析</h1><p>## </p>\n","categories":["programming"],"tags":["android","effect","snacks","animation","PageTransformer"]},{"title":"[露水]ViewPager动画类库","url":"http://halohoop.com/2017/06/23/dewdrops-vp_anima/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>图片比较大，可能需要加载一会儿。</p>\n<p><img src=\"https://github.com/halohoop/HaloPagerTrans/blob/master/demo0.gif\" alt=\"demo0\"></p>\n<h2 id=\"HOW-TO-USE\"><a href=\"#HOW-TO-USE\" class=\"headerlink\" title=\"HOW TO USE\"></a>HOW TO USE</h2><h3 id=\"Set-Animation-for-every-single-view\"><a href=\"#Set-Animation-for-every-single-view\" class=\"headerlink\" title=\"Set Animation for every single view\"></a>Set Animation for every single view</h3><ul>\n<li>By calling View.setTag() to set params of the animations</li>\n</ul>\n<pre><code>@Override\npublic void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n    View imageView3 = view.findViewById(R.id.imageView3);\n    imageView3.setTag(ChildsTranslateTransformer.KEY_OFFSET_X_FACTOR, 2f);\n    imageView3.setTag(ChildsTranslateTransformer.KEY_IS_REVERSE, true);\n    imageView3.setTag(ChildsTranslateTransformer.KEY_MARGIN_WHEN_REVERSE, -30f);\n\n    View line = view.findViewById(R.id.line);\n    line.setTag(ChildsTranslateTransformer.KEY_OFFSET_X_FACTOR, 2f);\n    line.setTag(ChildsTranslateTransformer.KEY_IS_REVERSE, true);\n    line.setTag(ChildsTranslateTransformer.KEY_MARGIN_WHEN_REVERSE, -70f);\n\n    View ll_top = view.findViewById(R.id.ll_top);\n    ll_top.setTag(ChildsTranslateTransformer.KEY_OFFSET_X_FACTOR, 2f);\n    ll_top.setTag(ChildsRotateTransformer.KEY_ROTATE, -90f);\n    ll_top.setTag(ChildsRotateTransformer.KEY_ROTATE_PIVOTX_RATIO, 1f);\n    ll_top.setTag(ChildsRotateTransformer.KEY_ROTATE_PIVOTY_RATIO, 0.5f);\n\n    View textView1 = view.findViewById(R.id.textView1);\n    textView1.setTag(ChildsTranslateTransformer.KEY_OFFSET_X_FACTOR, 3f);\n\n    View imageView1 = view.findViewById(R.id.imageView1);\n    imageView1.setTag(ChildsTranslateTransformer.KEY_OFFSET_X_FACTOR, 2f);\n    imageView1.setTag(ChildsRotateTransformer.KEY_ROTATE, 90f);\n    imageView1.setTag(ChildsRotateTransformer.KEY_ROTATE_PIVOTX_RATIO, 1f);\n    imageView1.setTag(ChildsRotateTransformer.KEY_ROTATE_PIVOTY_RATIO, 0.5f);\n}\n</code></pre><h3 id=\"Set-Animation-for-the-page-view-ViewGroup\"><a href=\"#Set-Animation-for-the-page-view-ViewGroup\" class=\"headerlink\" title=\"Set Animation for the page view(ViewGroup)\"></a>Set Animation for the page view(ViewGroup)</h3><ul>\n<li>The same, by calling View.setTag() to set params of the animations</li>\n</ul>\n<h3 id=\"Set-Complex-Animation-for-the-page-view-ViewGroup\"><a href=\"#Set-Complex-Animation-for-the-page-view-ViewGroup\" class=\"headerlink\" title=\"Set Complex Animation for the page view(ViewGroup)\"></a>Set Complex Animation for the page view(ViewGroup)</h3><ul>\n<li>choose one or more Transformers to add into the complex one</li>\n</ul>\n<pre><code>ComplexChildsTransformer complexChildsTransformer = new ComplexChildsTransformer();\ncomplexChildsTransformer.addTransformer(new ChildsTranslateTransformer());\ncomplexChildsTransformer.addTransformer(new ChildsRotateTransformer());\ncomplexChildsTransformer.addTransformer(new ChildsAlphaTransformer());\ncomplexChildsTransformer.addTransformer(new ChildsScaleTransformer());\n//choose one or more Transformers to add into the complex one\n//complexChildsTransformer.addTransformer(new PageDefaultTransformer());//普通vp滑动\n//complexChildsTransformer.addTransformer(new PageAlphaTransFormer(false/*可修改*/, true/*可修改*/));//透明度\n//complexChildsTransformer.addTransformer(new PageCubeInnerTransformer(/*可传参数*/));//立方体内部\n//complexChildsTransformer.addTransformer(new PageCubeOuterTransformer());//立方体外部\n//complexChildsTransformer.addTransformer(new PageDepthTransformer(/*可传参数*/));//深度变化\n//complexChildsTransformer.addTransformer(new PageExtrudingTransformer());//挤压\ncomplexChildsTransformer.addTransformer(new PageFlipTransformer(/*可传参数*/));//flip\n//complexChildsTransformer.addTransformer(new PageInRightUpTransformer());//右上到左下\n//complexChildsTransformer.addTransformer(new PageInRightDownTransformer());//右下到左上\n//complexChildsTransformer.addTransformer(new PageRotateTransformer(/*可传参数*/));//旋转\n//complexChildsTransformer.addTransformer(new PageZoomOutTransformer(/*可传参数*/));//Zoom out\nvp.setPageTransformer(true, complexChildsTransformer);\n</code></pre><h1 id=\"原码解析\"><a href=\"#原码解析\" class=\"headerlink\" title=\"##原码解析##\"></a><a href=\"http://halohoop.com/2017/06/24/snacks-vp_anima_detail/\"><strong>##原码解析##</strong></a></h1>","categories":["programming"],"tags":["android","dewdrops","effect"]},{"title":"[露水]review setContentView","url":"http://halohoop.com/2017/06/22/dewdrops-setcontentview/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>今晚重温了一下setContentView的整个流程，留下点东西，图一张。</p>\n<p><img src=\"/2017/06/22/dewdrops-setcontentview/demo0.png\" alt=\"demo0\"></p>\n","categories":["tricks"],"tags":["android","dewdrops"]},{"title":"[露水]小故事，大学问","url":"http://halohoop.com/2017/06/18/dewdrops-six_principle/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>一个人骑着单车走了二里地，他老婆依偎在车后座，他们是去接小孩放学，小孩叫迪迪，然后扔下单车开车走了。</p>\n<p>设计模式总结出来只是一种经验，告诉我们这种结构的代码会更好理解，更好维护，设计代码结构的时候不一定要遵循23+种设计模式，因为你可能受限于公司固有的业务逻辑，生搬硬套的去靠某一种设计模式可能会得到不好的效果。</p>\n<p>而我们要做的就是在设计代码结构的时候去遵循六种设计原则，SOLID，每每设计完一个小单元或者一个模块之后，可以照着这六种设计原则挨个审查是否符合。</p>\n<p><img src=\"/2017/06/18/dewdrops-six_principle/20170706_164307.320.png\" alt=\"demo0\"><br>[图为 任玉刚在CSDN技术峰会上的一个截屏，主题为 <strong>Android代码风格浅谈</strong>]</p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[饼干]ViewDragHelper.Callback.onEdgeLock是干嘛的么","url":"http://halohoop.com/2017/06/17/cookies-android_viewdraghelper_callback/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>ViewDragHelper.Callback提供给我们很多回调，灰常方便，网上很多文章都非常棒和详细，如果你还不知道ViewDragHelper这个神器怎么用，那你先去看看这些<a href=\"http://46aae4d1e2371e4aa769798941cef698.devproxy.yunshipei.com/hbl_for_android/article/details/51485827\" target=\"_blank\" rel=\"external\">文章</a>，不然下文你也看不懂。</p>\n<p>有一个回调大家都没有在意，或者说描述的含糊不清，这里要说的回调就是：</p>\n<pre><code>@Override\npublic boolean onEdgeLock(int edgeFlags) {\n    return false;\n}\n</code></pre><p>默认是返回false，从方法字面上去理解，那就是边缘锁定，我试着判断一个边缘然后返回true看看，是否边缘拖拽就失效了呢，代码如下：</p>\n<pre><code>@Override\npublic boolean onEdgeLock(int edgeFlags) {\n    return (edgeFlags&amp;ViewDragHelper.EDGE_LEFT)==ViewDragHelper.EDGE_LEFT;\n}\n</code></pre><p>显然结果和我预料的并不一样，难道这个方法是要手动调用的咩？这个时候咋办呢，当然是看源码，记住，一切答案都在源码。</p>\n<p><img src=\"/2017/06/17/cookies-android_viewdraghelper_callback/demo0.png\" alt=\"demo0\"></p>\n<p>注意1278行，源码中确实调用了onEdgeLock，为什么没有跑到这句，这里有些线索，比如：</p>\n<ul>\n<li>absDelta &lt; absODelta * 0.5f，绝对值后新旧数据的比较</li>\n</ul>\n<p>但是线索还不够，那就往上爬，找到checkNewEdgeDrag方法被调用的地方。当是LEFT和RIGHT的时候传入的是dx和dy，而TOP和BOTTOM的时候传入的是dy和dx，dx和dy调换了位置，恍然大悟了。</p>\n<p><img src=\"/2017/06/17/cookies-android_viewdraghelper_callback/demo1.png\" alt=\"demo1\"></p>\n<p>不多说，我把代码直接翻译成中文：</p>\n<ul>\n<li>当想要锁住的是<strong>左</strong>或者<strong>右</strong>的时候，如果<strong>左右</strong>滑动的距离还没<strong>上下</strong>滑动的距离的一半多，那就走回调onEdgeLock()；</li>\n<li>当想要锁住的是<strong>上</strong>或者<strong>下</strong>的时候，如果<strong>上下</strong>滑动的距离还没<strong>左右</strong>滑动的距离的一半多，那就走回调onEdgeLock()；</li>\n</ul>\n<p>当我们开启了边缘锁定模式，像这样：</p>\n<pre><code>viewDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);//这里锁定左边\n</code></pre><p>之后，我们在左边缘<strong>上下</strong>滑动的时候，就能够走回调onEdgeLock方法了。</p>\n<p>看看红框框出来的部分，</p>\n<h2 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h2><ul>\n<li><p>微信边滑退出，识别是边滑的时候锁定只能是左右滑，而不能是上下滑。</p>\n<ul>\n<li>当然我们可以自己在别的ViewDragHelper.Callback的回调中做限制,比如clampViewPositionHorizontal和clampViewPositionVertical，但是，神经病啊，用原生的不用你写那么多的判断逻辑啊。</li>\n</ul>\n</li>\n<li><p>我写的Demo在这里，请享用：</p>\n<ul>\n<li><a href=\"https://github.com/halohoop/AndroidDigIn/blob/c4d530b5943ab79e7dd6dc3dbbff1f6a76e214be/app/src/main/java/com/halohoop/androiddigin/widgets/DragViewGroup.java\" target=\"_blank\" rel=\"external\">DragViewGroup.java</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>答案都在源码.</li>\n<li>Stay hungry stay foolish!</li>\n</ul>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n","categories":["programming"],"tags":["cookies","view","android","ViewDragHelper"]},{"title":"[饼干]FragmentManager的popBackStack的使用","url":"http://halohoop.com/2017/06/16/cookies-frag_manager_popstack/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><ul>\n<li><p>用法：</p>\n<pre><code>//自己以上所有，不包括自己\ngetSupportFragmentManager().popBackStack(&quot;rt&quot;, 0);\n//自己以上所有，包括自己\ngetSupportFragmentManager().popBackStack(&quot;rt&quot;, 1);\n//最上层的一个\ngetSupportFragmentManager().popBackStack(null, 0);\n//最上层的一个\ngetSupportFragmentManager().popBackStack();\n//全部pop\ngetSupportFragmentManager().popBackStack(null, 1);\n</code></pre></li>\n<li><p>注意：</p>\n<ul>\n<li>popBackStack传入的第一个参数是addToBackStack(name)传入的参数，而不是Fragment的Tag；</li>\n<li>如果遇到两个name相同的连在一起的时候，两个移除，三个相同的就三个都移除…示例代码：<ul>\n<li>getFragmentManager().popBackStack(“rt”, 1); <ul>\n<li>也就是说，查找栈的顺序是先从后入栈的开始查找往下找，找到一个之后还继续找下一个如果还是一样的name就再找一个直到不是为止，然后将是的一并pop出栈。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实例代码Demo\"><a href=\"#实例代码Demo\" class=\"headerlink\" title=\"实例代码Demo\"></a>实例代码Demo</h2><p><a href=\"https://github.com/halohoop/AndroidDigIn#20fragmentmanager的popbackstack的使用\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/AndroidDigIn</a></p>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n<ul>\n<li>Stay hungry stay foolish!</li>\n</ul>\n","categories":["programming"],"tags":["cookies","android","Fragment"]},{"title":"[露水]adb无线调试","url":"http://halohoop.com/2017/06/15/dewdrops-adb_wifi/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>条件：</p>\n<ul>\n<li>一台开发版手机</li>\n<li>2个命令：<ul>\n<li>adb tcpip 55555</li>\n<li>adb yourDevicesIp:55555</li>\n</ul>\n</li>\n<li>4个步骤：<ul>\n<li>插入USB</li>\n<li>终端输入 adb tcpip 55555</li>\n<li>然后输入 adb yourDevicesIp:55555</li>\n<li>拔掉USB</li>\n</ul>\n</li>\n</ul>\n<p>比如：</p>\n<pre><code>[win cmd]\nD:\\workspaces\\androidstudio\\project&gt;adb tcpip 55555\nD:\\workspaces\\androidstudio\\project&gt;adb connect 192.168.199.156:55555\nconnected to 192.168.199.156:55555\n</code></pre><p><strong>无线调试还支持 instant run 和 Debug 咧。</strong></p>\n<p><a href=\"https://developer.android.com/studio/command-line/adb.html#wireless\" target=\"_blank\" rel=\"external\">参考</a></p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[饼干]Kotlin Trick 003-滚吧工具类","url":"http://halohoop.com/2017/06/14/cookies-kotlin-trick-003/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java:\"></a>Java:</h2><pre><code>class Utils {\n    public static char getLastChar(String str){\n        return str.charAt(s.length()-1);\n    }\n}\n</code></pre><p>调用:</p>\n<pre><code>char c = Utils.getLastChar(&quot;halohoop.com&quot;);//得到m\n</code></pre><h2 id=\"Annoying：\"><a href=\"#Annoying：\" class=\"headerlink\" title=\"Annoying：\"></a>Annoying：</h2><p>增加类</p>\n<h2 id=\"When-it-comes-to-Kotlin：\"><a href=\"#When-it-comes-to-Kotlin：\" class=\"headerlink\" title=\"When it comes to Kotlin：\"></a>When it comes to Kotlin：</h2><p>不需要增加额外的类。</p>\n<pre><code>//扩展属性\ninline val String.lastC: Char\n    get() = get(length - 1)\n</code></pre><p>或者：</p>\n<pre><code>//扩展方法\ninline fun String.getLastChar() : Char{\n    return get(length-1)\n}\n</code></pre><p>调用:</p>\n<pre><code>var c = &quot;halohoop.com&quot;.lastC//得到m\n</code></pre><p>或者</p>\n<pre><code>var c = &quot;halohoop.com&quot;.getLastChar()//得到m\n</code></pre>","categories":["programming"],"tags":["cookies","android","kotlin"]},{"title":"[饼干]Kotlin Trick 002-滚吧重载方法","url":"http://halohoop.com/2017/06/13/cookies-kotlin-trick-002/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java:\"></a>Java:</h2><pre><code>void test(int i){\n}\nvoid test(String j){\n}\nvoid test(int i, String j){\n}\n</code></pre><p>调用:</p>\n<pre><code>test(1);\ntest(&quot;aaa&quot;);\ntest(1,&quot;aaa&quot;);\n</code></pre><h2 id=\"Annoying：\"><a href=\"#Annoying：\" class=\"headerlink\" title=\"Annoying：\"></a>Annoying：</h2><p>写太多重载了，眼都花了</p>\n<h2 id=\"When-it-comes-to-Kotlin：\"><a href=\"#When-it-comes-to-Kotlin：\" class=\"headerlink\" title=\"When it comes to Kotlin：\"></a>When it comes to Kotlin：</h2><pre><code>//一个足矣\nfun test(i:int = 0, j:String = &quot;&quot;){\n}\n</code></pre><p>调用:</p>\n<pre><code>test();//有默认值，可以不用传\ntest(1);\ntest(1,&quot;aaa&quot;);\ntest(j = &quot;aaa&quot;);//非第一个需要传递参数名字，这也能增加可读性\n</code></pre>","categories":["programming"],"tags":["cookies","android","kotlin"]},{"title":"[大餐]加快gradle构建速度","url":"http://halohoop.com/2017/06/13/meals-speedup_gradle_build/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></p>\n<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>AS中gradle构建一般可以分为三种，</p>\n<p>1.从0开始构建，Full Build；</p>\n<p>2.修改源代码后构建，之前构建过，Incremental build java change；</p>\n<p>3.修改资源文件后构建，之前构建过，Incremental build resource change。</p>\n<p>从这三方面其实都可以有切入点来进行提速，gradle插件3.0做了大改，优化了很多东西，包括gradle依赖系统以及缓存系统，这些都是直接影响构建速度的因素，整理了有10+个小技巧可以加快我们的构建速度，下面请听我一一道来。</p>\n<h2 id=\"正餐：\"><a href=\"#正餐：\" class=\"headerlink\" title=\"正餐：\"></a>正餐：</h2><h3 id=\"技巧1：使用最新版本的gradle插件\"><a href=\"#技巧1：使用最新版本的gradle插件\" class=\"headerlink\" title=\"技巧1：使用最新版本的gradle插件\"></a>技巧1：使用最新版本的gradle插件</h3><pre><code>buildscript {\n    repositories {\n        maven { url &apos;https://maven.google.com&apos; }\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:3.0.0-alpha1&apos;\n    }\n    ...\n}\n</code></pre><p>看到google.com之后，相信你应该知道要拿个“梯子”的，所以我说升级as最方便嘛，而现在gradle的版本已经更新到alpha1+了(现在是2017年06月12日)，根据谷歌官方只要是3.0+，也就是以2017I/O大会的版本开始就可以。</p>\n<h3 id=\"技巧2：避免使用legacy-multidex\"><a href=\"#技巧2：避免使用legacy-multidex\" class=\"headerlink\" title=\"技巧2：避免使用legacy multidex\"></a>技巧2：避免使用legacy multidex</h3><p>当app方法数量超过64k的时候就会编译失败，早期版本的构建系统按如下方式报告这一错误：</p>\n<pre><code>Conversion to Dalvik format failed:\nUnable to execute dex: method ID not in [0, 0xffff]: 65536\n</code></pre><p>较新版本的 Android 构建系统虽然显示的错误不同，但指示的是同一问题：</p>\n<pre><code>trouble writing output:\nToo many field references: 131000; max is 65536.\nYou may try using --multi-dex option.\n</code></pre><p>使用multidex分包处理是谷歌官方给我们提供的解决方案，由于分包被内置支持在5.0以及之后，当我们需要兼容的版本跨越5.0也就是api21的时候，比如说14–23，那么我们需要使用兼容库：</p>\n<pre><code>com.android.support:multidex:1.0.0\n</code></pre><p>使用兼容库能让我们的低版本的也进行分包处理，<a href=\"https://developer.android.com/studio/build/multidex.html#about\" target=\"_blank\" rel=\"external\">具体如何操作gradle需要配置什么Application需要如何设置</a>等不是本文重点，请各位自行谷歌、百度。</p>\n<p>根据谷歌官方描述，使用兼容库会明显拖慢构建，也就是如果你的调试机器版本低于5.0，又进行了分包处理，那么当你点击那个绿色构建按钮▶或者使用命令行gradlew构建的时候，那你可以先去吃一顿饭先了（Just kidding!）。</p>\n<p>所以我们在开发调试的时候尽量使用高版本的手机5.0+，等功能完成了，后面做兼容低版本的时候再使用低版本的手机进行调试。可能有人会说，我在开发功能的时候如果不实时调试低版本的兼容问题后期可能有问题，关于这一点，我想说的是一点是经验问题，经验足的人就是能够知道你这段代码写出来可能的结果，这是内功，不可言状，却又确实存在的能力，我见过这样的人，你没写出来他就能够知道运行的结果，另一点是我们需要相信google的兼容团队给我们的兼容方案是能够解决绝大部分的兼容问题的，我指的兼容方案是指使用appcompat、support等之类的兼容库。</p>\n<h3 id=\"技巧3：关闭multi-apk\"><a href=\"#技巧3：关闭multi-apk\" class=\"headerlink\" title=\"技巧3：关闭multi apk\"></a>技巧3：关闭multi apk</h3><p>如果你的项目需要编译出多个density或者多个abi（CPU架构）的APK，那么这也是开发构建的时候不需要做的操作，因为在你手上调试的机器只是一种density一种abi，因此我们在构建的时候可以将<a href=\"https://developer.android.com/studio/build/configure-apk-splits.html\" target=\"_blank\" rel=\"external\">multi-apk</a>的构建给去除。可以进行如下配置：</p>\n<pre><code>splits {\n    density {\n        //enable true\n        enable false\n        ...\n    }\n    abi {\n        //enable true\n        enable false\n        ...\n    }\n}\n</code></pre><p>但是显然这趟配置影响全局配置，后期还可能忘记改回来，更灵活一点的方式可以这样：</p>\n<pre><code>android {\n    ...\n    splits {\n        ...\n    ｝\n    if(project.hasProperty(&apos;HaloDevBuild&apos;)){\n        splits.abi.enable = false;\n        splits.density.enable = false;\n    }\n    ...\n}\n</code></pre><p>或者，可以更加细致一点：</p>\n<pre><code>android {\n    ...\n    splits {\n        ...\n    ｝\n    if(project.hasProperty(&apos;HaloDevBuild&apos;)){\n        splits.density.enable = false\n        splits.abi {\n            enable true\n            reset()\n            include &apos;arm64-v8a&apos; //select ABIs to build APKs for\n            universalApk false //whether generate an additional APK that contains all the ABIs\n        }\n        aaptOptions.cruncherEnabled = false\n    }\n    ...\n}\n</code></pre><p>注意project没有s，不是projects。<strong>并且这个判断的代码必须置于splits块的下面，否则就可能设置完之后就又被覆盖回来了</strong><br>“HaloDevBuild”属性的字符串我们可以自定义，在gradle写好这个判断之后，我们就可以在命令行编译了，命令如下：</p>\n<pre><code>./gradlew 项目名:变体 -PHaloDevBuild\n</code></pre><p>比如：</p>\n<pre><code>gradlew app:assembleDevelopmentDebug -PHaloDevBuild\n</code></pre><p>又或者可以构建顺带安装了：</p>\n<pre><code>gradlew demo:installdevelopmentDebug -PHaloDevBuild\n</code></pre><p>-P之后表示要传递的属性。当然我们如果需要在as中点击绿色构建按钮▶编译，那就要设置一下每次都要传入属性：</p>\n<p><img src=\"/2017/06/13/meals-speedup_gradle_build/demo0.png\" alt=\"demo0\"></p>\n<p>另外，我们可以这样获取Android手机CPU/ABI型号：</p>\n<pre><code>String CPU_ABI = android.os.Build.CPU_ABI;//过时了\nString CPU_ABIs[] = android.os.Build.SUPPORTED_ABIS;\n</code></pre><h3 id=\"技巧4：使用最少的资源打包\"><a href=\"#技巧4：使用最少的资源打包\" class=\"headerlink\" title=\"技巧4：使用最少的资源打包\"></a>技巧4：使用最少的资源打包</h3><p>和上面的思路一样，我们开发调试的时候只需要用到一种语言和一套资源文件。所以我们打包的时候不需要将所有的东西都放到这个调试的apk中。我们可以采用<a href=\"https://developer.android.com/studio/build/build-variants.html\" target=\"_blank\" rel=\"external\">定义变体</a>的方式来完成，注意下面的resConfigs属性指定了要保留的素材资源文件和语言资源文件。</p>\n<pre><code>android {\n    ...\n    flavorDimensions &quot;dev&quot;\n    productFlavors {\n        development {\n            dimension &quot;dev&quot;\n            resConfigs &quot;en&quot;, &quot;xxhdpi&quot;\n            ...\n        }\n    }\n}\n</code></pre><h3 id=\"技巧5-关闭aapt对png的优化\"><a href=\"#技巧5-关闭aapt对png的优化\" class=\"headerlink\" title=\"技巧5:关闭aapt对png的优化\"></a>技巧5:关闭aapt对png的优化</h3><p>aapt打包时候对资源图片的处理也会耗时，这里主要针对PNG，我们可以暂时关闭这种处理，还是用到上面的技巧，gradle配置如下：</p>\n<pre><code>android {\n    ...\n    if(projects.hasProperty(&apos;HaloDevBuild&apos;)){\n        splits.abi.enable = false;\n        splits.density.enable = false;\n        aaptOptions.cruncherEnabled = false\n    }\n    ...\n}\n</code></pre><p>当然如果我们将PNG转为webP也可以是一种优化方案。as2.3+支持直接转换，右键直接png图片选则convert to webP。当然webP是有版本要求的，所以请注意其用法，只有4.0及以上的android手机支持webP，不过当然想要低版本的支持webP可以引入以下这个裤，另，更多webP详情非本文重点请自行百度了解。</p>\n<p><a href=\"https://github.com/alexey-pelykh/webp-android-backport\" target=\"_blank\" rel=\"external\">https://github.com/alexey-pelykh/webp-android-backport</a></p>\n<h3 id=\"技巧6：使用instant-run\"><a href=\"#技巧6：使用instant-run\" class=\"headerlink\" title=\"技巧6：使用instant run\"></a>技巧6：使用instant run</h3><p>多使用instant run，根据谷歌的描述，as3.0和2.0的instant run有巨大的差别，做了很多的优化，instant run要求调试的机器必须要在api21或者以上，而不是你的项目最小版本要在21或者以上。还有一点就是使用instant run的时候，如果我们首次构建是从0开始的，那么会比不使用instant run慢一点，因为需要为后面的instant run的冷热交换去准备一些额外的东西，然而如果后面一直都使用instant run，那么首次构建的延缓的时间就能很快被挽回来。</p>\n<h3 id=\"技巧7：避免写一些不必要的更改\"><a href=\"#技巧7：避免写一些不必要的更改\" class=\"headerlink\" title=\"技巧7：避免写一些不必要的更改\"></a>技巧7：避免写一些不必要的更改</h3><p>有些开发者为了方便会直接使用时间戳来作为每次构建的版本号（或者是自己的一套计算算法），像这样：</p>\n<pre><code>def buildDataTime = new Date().format(&apos;yyMMddHHmm&apos;).toInteger()\nandroid {\n    ...\n    defaultConfig {\n        versionCode buildDateTime\n        ...\n    }\n}\n</code></pre><p>这个一定程度上方便了我们，但是对于gradle构建系统来说，这不是好事。由于每次版本号都有修改，这就直接导致清单文件Manifest的更改。而清单文件的修改势必会趋势构建系统重新审视整个项目情况，这会增加很多额外的时间，这在开发调试的时候根本没有必要。</p>\n<p>还是利用上面的技巧，我们可以这样：</p>\n<pre><code>def buildDataTime = project.hasProperty(&apos;HaloDevBuild&apos;)? 100 : new Date().format(&apos;yyMMddHHmm&apos;).toInteger()\nandroid {\n    ...\n    defaultConfig {\n        versionCode buildDateTime\n        ...\n    }\n}\n</code></pre><h3 id=\"技巧8：类库不要使用动态的版本\"><a href=\"#技巧8：类库不要使用动态的版本\" class=\"headerlink\" title=\"技巧8：类库不要使用动态的版本\"></a>技巧8：类库不要使用动态的版本</h3><p>项目中可能会这样配置：</p>\n<pre><code>dependencies {\n    ...\n    compile &apos;com.android.support:appcompat-v7:+&apos;\n}\n</code></pre><p>这个加号+，导致gradle每次构建都要检查新的版本。即使你希望每次都用最新但是还是不好，因为库可能已经有很大的变化了，但是你是基于旧版开发的，所以为了安全不要这样设置。其实这和我们coding还是一样的道理，我们码代码的时候肯定会考虑如何能让别人的修改不影响到我们自己的，因此这个加号使不得，使不得。</p>\n<h3 id=\"技巧9：查看jvm使用的内存是否合适\"><a href=\"#技巧9：查看jvm使用的内存是否合适\" class=\"headerlink\" title=\"技巧9：查看jvm使用的内存是否合适\"></a>技巧9：查看jvm使用的内存是否合适</h3><p><img src=\"/2017/06/13/meals-speedup_gradle_build/demo1.png\" alt=\"demo1\"></p>\n<p>我一般设置为2g，这个根据项目的不同可能会有不同效果，所以可以试着稍微调整一下。</p>\n<h3 id=\"技巧10：打开gradle新的缓存机制\"><a href=\"#技巧10：打开gradle新的缓存机制\" class=\"headerlink\" title=\"技巧10：打开gradle新的缓存机制\"></a>技巧10：打开gradle新的缓存机制</h3><p>我们可以通过一个设置使用这种新的缓存机制，如下：</p>\n<pre><code>//在gradle.properties中+一行\norg.gradle.caching=true\n</code></pre><p>文章开头也提到过，Gradle 3.5（现在20170612的gradle版本已经4.0了）新的机制，可以缓存所有任务的输出。这个和as2.3时候介绍的build 缓存不一样，build 缓存只缓存预dex的外部libs。而任何时候的构建缓存其实都是可复用的，比如切换分支之后，还可以用其他分支时候的构建缓存。</p>\n<p>当然，根据谷歌官方描述，这个设置的背后还有很多需要完善的地方，使用的同时，我们可以有更多后期优化的期待。</p>\n<h3 id=\"技巧11：使用新的依赖机制\"><a href=\"#技巧11：使用新的依赖机制\" class=\"headerlink\" title=\"技巧11：使用新的依赖机制\"></a>技巧11：使用新的依赖机制</h3><p>按照官方的描述，gradle3.0之前，构建系统的依赖关系被认为是一种完全错误的方式，举一个例子：</p>\n<p>app依赖了库libX，库libX又依赖库libY。</p>\n<p>app：</p>\n<pre><code>compile &apos;libX&apos;\n</code></pre><p>libX：</p>\n<pre><code>compile &apos;libY&apos;\n</code></pre><p>如果在app中调用了libY的方法，这个时候如果libY中的方法做了改变，那么由于libY被和libX和app都有依赖被依赖关系，这时候如果构建libY势必会导致libX和app也重新构建。</p>\n<p>这应该是个完全错误的依赖方式，正确的方式应该是既然app只依赖了libX那就不应该知道libY中的api，然而这在构建系统3.0（gradle插件）之前都是这样存在的，因此3.0做了改变，引入了新的依赖形式，api和implementation来替换compile。</p>\n<ul>\n<li>implementation：表示我依赖你，但是你的api不会被我重新分享出去了。</li>\n<li>api：表示我依赖你，但是你的api会被我重新分享出去了。</li>\n</ul>\n<p>那么在看上面的例子就变成了：</p>\n<p>app：</p>\n<pre><code>implementation &apos;libX&apos;\n</code></pre><p>libX：</p>\n<pre><code>api &apos;libY&apos;\n</code></pre><p>由于存在之前的这种依赖传递的错误机制，因此我们项目中很可能就出现了这种依赖传递之后导致一个小修改就把所有库都构建一遍的情况，因此我们花一些时间将一些库的compile都替换成api和impementation对我们是有好处的，一来有效缩短构建时间，而来真正搞清楚项目中依赖的情况，那些api需要依赖传递，哪些不需要。</p>\n<p>当然我们还是可以继续使用compile，不过这种方式已经是过时的了，我们只要更新了最新插件，那么新建了项目就会发现所有的compile都会被换成了implementation。相关的修改还有androidTestImplementation和testImplementation，对应的是原来的androidTestCompile和testCompile。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>根据上述技巧，我写了一个小demo：</p>\n<p><a href=\"https://github.com/halohoop/SpeedUpGradleBuild2\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/SpeedUpGradleBuild2</a></p>\n<ul>\n<li>Stay hungry stay foolish!</li>\n</ul>\n","categories":["programming"],"tags":["android","meals","gradle","构建"]},{"title":"[大餐]开发摘记1--我的Fragment通信的框架","url":"http://halohoop.com/2017/06/09/meals-android-fishing/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>如果把通信比作钓鱼，如果每次都有鱼上钩，那么我想可以分为以下四种：</p>\n<ul>\n<li>1.鱼钩上<strong>不钩</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线断了，连线带钩和鱼都没了。</li>\n<li>2.鱼钩上<strong>钩上</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线断了，连线带钩和鱼带饵料都没了。</li>\n<li>3.鱼钩上<strong>不钩</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线<strong>没断</strong>，连线带钩和鱼带饵料都<strong>拉回来</strong>了。</li>\n<li>4.鱼钩上<strong>钩上</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线<strong>没断</strong>，连线带钩和鱼带饵料都<strong>拉回来</strong>了。</li>\n</ul>\n<p>其实这四种就可以对应着四种不同的通信：</p>\n<ul>\n<li>1.A向发了一个<strong>空的通知</strong>让B响应了，A不需要知道B是否响应(鱼线断了)。</li>\n<li>2.A向发了一个<strong>携带参数的通知</strong>让B响应了，A不需要知道B是否响应(鱼线断了)。</li>\n<li>3.A向发了一个<strong>空的通知</strong>让B响应了，A需要知道B是否响应，最终A得到了B响应结果(鱼线完好，成功回收)。</li>\n<li>4.A向发了一个<strong>携带参数的通知</strong>让B响应了，A需要知道B是否响应，最终A得到了B响应结果(鱼线完好，成功回收)。</li>\n</ul>\n<p>再说的简单一点，那就是：</p>\n<ul>\n<li>1.调用“void func()”方法，无参无返回值。</li>\n<li>2.调用“void func(P p)”方法，有参无返回值。</li>\n<li>3.调用“R func()”方法，无参有返回值。</li>\n<li>4.调用“R func(P p)”方法，有参有返回值。</li>\n</ul>\n<p>因为通信无非就是这四种方法，那么就可以抽象出来的这四类方法的类，如果使用四个容器装着，在合适的时候往里添加，并且在合适的时候取出来调用，那么势必可以变成一个解耦通信框架。</p>\n<p>后面会陆续记录开发这个小框架的心路历程。</p>\n<hr>\n<p><img src=\"/2017/06/09/meals-android-fishing/demo0.png\" alt=\"\"></p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/halohoop/Fishing\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/Fishing</a></p>\n<p>已经可以正常使用了。</p>\n","categories":["programming"],"tags":["view","android","meals","开发摘记"]},{"title":"[露水]你知道卫语句不","url":"http://halohoop.com/2017/06/08/dewdrops-weiyuju/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h3 id=\"卫语句\"><a href=\"#卫语句\" class=\"headerlink\" title=\"卫语句\"></a>卫语句</h3><p>在<a href=\"http://halohoop.com/2017/06/08/dewdrops-weiyuju/《阿里巴巴Java开发手册》.pdf\">《阿里巴巴Java开发手册》.pdf</a>中的15页有提到“卫语句”，如下图。</p>\n<p><img src=\"/2017/06/08/dewdrops-weiyuju/demo0.png\" alt=\"demo0\"></p>\n<p>说的是：</p>\n<h3 id=\"我们不要这样写：\"><a href=\"#我们不要这样写：\" class=\"headerlink\" title=\"我们不要这样写：\"></a>我们不要这样写：</h3><pre><code>if(){\n\n}else if(){\n\n}else if(){\n\n}...\n</code></pre><h3 id=\"而要这样写\"><a href=\"#而要这样写\" class=\"headerlink\" title=\"而要这样写\"></a>而要这样写</h3><pre><code>if(){\n    return;\n}\nif(){\n    return;\n}\nif(){\n    return;\n}\n</code></pre><p>虽然不是很明白更深层的原因，但是我表示对后面那一句“或者状态模式来实现”很有感触，因为正在做的一个小框架就打算使用状态模式来摒弃一堆的if-else判断。</p>\n","categories":["programming"],"tags":["dewdrops"]},{"title":"[露水]客观，有时候需要精分","url":"http://halohoop.com/2017/06/08/dewdrops-be_objective/","content":"<link href=\"/style.css\" rel=\"stylesheet\" type=\"text/css\"><script src=\"/crypto-js.js\"></script><script src=\"/mcommon.js\"></script><script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <div id=\"security\"> <div class=\"input-container\"> <input type=\"password\" class=\"form-control\" id=\"pass\" placeholder=\" Please enter the password to read the blog. \" /> <label for=\"pass\"> Please enter the password to read the blog. </label> <div class=\"bottom-line\"></div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> U2FsdGVkX18+SRsOaqw7ANqtxYcLNCtiFaF72d+WIUNXObbOb+ZrE72u1Ey2Ao0ZIelNnu1rC4T0dUrTIefbm6Pi5jx144CgPXx4gbwW2a5BV3xaIcSXtmafpW7Yeosru7wbw6wPbgXA1CQBIwitLid3BDcgs+9NJrRtmlOnO9/wXWKulLRoZylvsEX58xEsn0FgZpwbd5pgDtBCzy5V+xANk/DFpb8X3yxdKJfXaD9KLo6DW9znfC5OoEnwHdeXaEaLDKq/P8WlZ0PkjwEy2czbd/Yt3ecb5VePj6/OKufWeNsVYNIM36mMkQVK4FM8L6fOo3QAM0D13WCutmm8STEDcN+btaz65sJGNa7hY/1Q6d4MZOsbaAi856PhlaLheqIe05JQSXpYnYc0t3a7q5ZVDRi12AOTaY1Us0x/INAbKRBHtbtNIznQnadg1KYF7VzJEBmF+a4QUj0BVzcJqS/7MgTFNWVKOQN8V5ycgJYTsC6hc9FpySE4PAbSL6Qmd0muADEAUxcS+SLPNwvPvLZYyT68SMEBGvXA9/CQf0GG/2Lex30UPitYgLvKz5ZN36+6t530OdcCHw0C4Urr/OeRJIhxVlr2q572WopcyyvXXGz7nwIl95QFk6meW7ti8nkGu2uCSzdPgY5Rta+i22+x+Mu5MZRZcS/4xYIRq4WZK3CfZTDs1g6t2VOPGH6RXUpGAAq0la0H7/VdFr+CHZasgelqQM2pTO8g+HuiUDxGrZ8lRjBape8usBsTUf1Zxv2SCLIC9EjDZrjEvBYG+I3rnxN7RIBEybriPJ/ndT0j4MzKGcBWaAVUqys8kGli2qgvwDLxqM8qvRcH5I3jsZr36u14c2Dhc01kJAeYw6CWeFtuWQmKSkzQ35ZqsLfxh1Lo4cdbTMBwJrU8wNLjm6k1RL2oKh6vtSBDkricK71usOH145XCteRkR/yrzhmFGRXrDeCKO+yyhyq+Zbpg4g2n26Z8YvgFZjJFxIqvVnlwWvlqISnNGzU2F1SupHccEmP4TR+Ek2v67hn7AyB0nEQs/CI1xpp/1lQiAEPPkz5o5UwjUAYoW1yQYELJPW7EEejiv3EJvjL3IGxNbBD4DEdhlXlB9JGyJtabKywzxF7RPk1OG8rtmxKx9iDLERBqmHH4iw9hZlGM/ArewXHbzVB0z05oKNwKQ45bHgOAzrYTQMu1dj67IyKlrX1g5UMnqBdLIUDL9n2+SHxWwB0rsqiHQ9fvcAgiWbFGS112pQ1kM7gNnejwVwOwQiOs9o7T3j3XFCLw1DsaeN28ArpAvG87mSsklNCYS98T4nTe+SaEnlpPFmvF9z0Hj5+N3Qeoe2R6s3PGF6axkpwfFiot4ZXqpat9PDm3aHrJk+m6qE9bQkNsWmQEATlOmPpP+BzoBLDn6mqKOm0KGUz6fTRKDP4E0laPC2yquI5mBL60e6sUCnSJHd11PWOnIVKAipEzyHFeGRcBZNKUSJ76KFSStu8jL3lHvPT/22hROAkMXh7MAQ2Q0z45jHursWFHXJqjp/sGSnI8t0GxmrDV/bpJ/EM9hJjxz+pfgd2w0pye2pIQNR6Q11ts8pV8sqFSeBQiL2896myyNMvKPjMnOidbENYrs4q5/HIBfZ9T8NTv42aC19OmeYnaHDtxz61X/E03Jql2KTe5DIwxbkSZYdCpl2loT6QuD/AV7pGbvawcmHXEEH2iEMgQMjjC8VFtLiAIC1qQl5eoyzZKb4rruy0OqMTKXdGUo0PDfWsUiS3ufk/XpTj3yUixOV7swoB+rTcXdGXuEuC2VAcKYkrlzju5xLUSphfnlYrmqAL8tKdozUz8t/ec7PJbn444xdbn3t3vSMvsd3dKk4uMxi1p7pfaFr/962F5U+IMcjDopxygAUT9oTcj8RlcTbtQVfPl6D0zy4oPoBmnRYiK2M0I3GU4JdQWKILRAA9Xa0g3tzOsqfsK7HjCMcARxUOWnDXYSUpv8ZmSIvvwUOzRF1XZ7D9+5WuNOb/62mxuobLPftUS8wmx3YjfJl4MBDSdxxgnC+rxENekhhqE1bnspEEa+SSKEB2Sb2FbmSS5WCdo+x937t9jAGUPMmlo8HjIWhC1NaBuLevuuzq7ldwjqinVjucx7ykKaA0A+T2A2khDOBeBBc8uTeHkwBgkQ1oDB8xJimVplU9+6vwHgdbbEBqhwod9JwGZRwn4aTBF7AEdTW1nyW0IEVw3NBH49wK8reiDa94n4za4/LAx/FRron26M9we3D8xbMfpZGMCex50zXmmaKorsDztILbCy0a4MpmnKeS6tJnAS1YkYcf98aDD7Cx2cQWepQUH3FS3TxKte+R7nfb1quWtsiV1REeL1P3pZbPuT7O5OoKA7o5WCxwwRFv86ZA6mjLaidbuSBDHHRWZYV3Z1+c8fTYLoI0D9sv9ZkgRitNIXODX+mMOod5FpsA/MTs1gWYsQOsMRbZZfRSCW3TfzUDGMmL9DYFxylO0Hm2IaPUjzBZC/Pe8FTu8idpsAd5mlpBbKVkPTQ3ldgtnaousdHcKYGEA1G6yz1h8AF0eFxhfUmkaeG0rZwRJG+GqhLYk63MxXxYycll5hjMq/WQd4odxAhET5LCsooUi879ULVdfZK0SrCz/CUgWvPxL6liyutBghbsQROdsIfWoEdR+fpsOw8uAArSBnVgcjfvDC7YYr0jp29gkgeDyot+ijgPhdnQzDS8CxRkY0F9Y3oVct1fx2fvax4ymu5bkJBAGq9aSPID8fPQUGj4WgAsDSStmYFeurxJiMOGmIZp1XE0ZgNsWDl8esYbQPux1HInxvPlE85YuXK97EX+ALiRVsIDdu9yK8A+HxQg0UZOtxdySnKndRgZYr7OtbuWEx8T4QurDAPR76m5BD0dySR5rmutxWQoEu25DJVOx+55y40Fezh4jB9WTuL87SYBI+/OSCJ/WRvto9+MsXMtFSzwFif1RRop4C7L5dT6mGTjPhAmqwq1uV7YyxjW5iWMUaIy+0xXT4DQ0ffPUtM7YZhprddAskWcd88oGChtOiV+wvvi0rjYw9SdrIDZJ4bbQDpoekYzNMC0PF44+N2Vx9gk9gMyfoTC4XSn8Vml/ADgdFabg2q5CzAstQi9gT5SLUJDrAoSGMq9PvDhi0Dm83kntB07x25rvzr17CAtB3fGdUscyWNJm5Ui1K9vkQ8rw9mTC57765A836Y7HFswKMMBdacbYqij/22etd4TJFsnv+Kn3gkVZYNkd4tMm5x9TtK41AuoSkoa4qMp2qsutSilXscF9feRV9f+L3pKiwolCrfSyP4nByvX1RtMIvDMxu2QOSNIyZ8YlyunSKMy988+/qtFtzBVT7PGgNEq6fmvQso8= </div>","categories":["tricks"],"tags":["dewdrops"]},{"title":"[露水]多看书有多重要","url":"http://halohoop.com/2017/06/06/dewdrops-importance-of-books/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>多看书有多重要，为了拓展思维，在大脑留下更多的种子，也许你没有全部记住，但是你留下了种子，日后接触到相关的内容(肥料)的时候，你可以快速的回来生根发芽。</p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[饼干]安卓小秘密-不扩大view宽高增加其可触控范围","url":"http://halohoop.com/2017/06/06/cookies-android-touchdelegate/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>今天我要记录的是<strong>TouchDelegate</strong>，有很多人应该都不知道还有这个东西，知道的孩子都没你们事了，都散了散了吧，不知道的请往下看。其实也不算什么秘密，只要你仔细的走过神迹一样的事件分发的源码，很容易发现的。</p>\n<h2 id=\"场景：\"><a href=\"#场景：\" class=\"headerlink\" title=\"场景：\"></a>场景：</h2><p>如下图，有这样一个场景，View a 需要有这么大，比如可以是一个按钮，UI要求显示View a的黑框部分，但是为了更好的用户体验，我们一般会增大其触控范围，比如点击绿框中都能够触发a的事件，咋做？（说好的不卖关子的呢？）</p>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo0.png\" alt=\"demo0\"></p>\n<h2 id=\"Don’t-do\"><a href=\"#Don’t-do\" class=\"headerlink\" title=\"Don’t do:\"></a>Don’t do:</h2><ul>\n<li>增加a的Padding?<ul>\n<li>后期如果修改bgColor，那么不好了，绿色框内全变色。</li>\n</ul>\n</li>\n<li>套多一层透明的FrameLayout？<ul>\n<li>增加布局复杂度，我TM一脚飞死你。 </li>\n</ul>\n</li>\n<li>自定义view限制绘制区域？<ul>\n<li>写完了？你很棒！但是你可以收拾包袱走人了。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"What-should-do-How-to-use-TouchDelegate-：\"><a href=\"#What-should-do-How-to-use-TouchDelegate-：\" class=\"headerlink\" title=\"What should do (How to use TouchDelegate)：\"></a>What should do (How to use TouchDelegate)：</h2><p>要学会站在巨人的肩膀，要知道，<strong>“你遇到的，巨人也会遇到”</strong>，巨人给我们留下了<strong>TouchDelegate</strong></p>\n<h3 id=\"直接上菜：\"><a href=\"#直接上菜：\" class=\"headerlink\" title=\"直接上菜：\"></a>直接上菜：</h3><p>注意方法ViewGroup.setTouchDelegate(Rect,View)</p>\n<p>以下代码出自我一个自定义View—<a href=\"https://github.com/halohoop/UsoppBubble/blob/master/lib/src/main/java/com/halohoop/usoppbubble/widget/UsoppBubble.java\" target=\"_blank\" rel=\"external\">UsoppBubble.java</a></p>\n<pre><code>@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    if (changed) {\n        float largedSize = (bottom - top) * mTouchAreaLargerRatio;//乘以放大倍数\n        int deltaY = (int) (largedSize - (bottom - top));\n        int deltaX = largedSize &gt; (right - left) ? (int) (largedSize - (right - left)) : 0;\n        ViewGroup vg = (ViewGroup) getParent();\n        Rect rect = new Rect(left - deltaX, top - deltaY, right + deltaX, bottom + deltaY);\n        //构建出来的Rect对象就相当于绿色框框，而this就是这个view的实例。\n        vg.setTouchDelegate(new TouchDelegate(rect, this));\n    }\n}\n</code></pre><p>相信上述代码是极度容易的，ViewGroup.setTouchDelegate(Rect,View)接受两个参数：</p>\n<ul>\n<li>可触控区域。</li>\n<li>谁(哪个子view)需要用这个可触控区域。</li>\n</ul>\n<h2 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h2><ul>\n<li>QQ消息气泡可触控区域</li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo1.png\" alt=\"demo1\"></p>\n<ul>\n<li>当然我也模仿qq做了一个<a href=\"https://github.com/halohoop/UsoppBubble\" target=\"_blank\" rel=\"external\">自己的消息气泡版本</a></li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo2.gif\" alt=\"demo2\"></p>\n<ul>\n<li>小米贴边悬浮球点击唤醒</li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo3.png\" alt=\"demo3\"></p>\n<ul>\n<li>锤子的闪念胶囊贴边点击唤醒</li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo4.png\" alt=\"demo4\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>View.setTouchDelegate(Rect,View)，这句还不够吗？还要我怎样？</li>\n<li>你遇到的，巨人也会遇到，如果换位思考一下，你就是“巨人”，那么子View获取到的触摸事件是从ViewGroup分发下来的，那么如果在分发之前加一些条件判断，比如区域什么的，那么TouchDelegate这玩意儿是不是就出来了呢？</li>\n<li>Stay hungry stay foolish!</li>\n</ul>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n<hr>\n<p>确保这文章被看完了，我在上面留了一个无伤大雅的bug，不知道有人发现没有，那就是：</p>\n<p><em>setTouchDelegate其实是View的方法。而ViewGroup : View，无伤大雅。</em></p>\n","categories":["programming"],"tags":["cookies","view","android"]},{"title":"[饼干]Kotlin Trick 001-省略一些重复的工作","url":"http://halohoop.com/2017/06/05/cookies-kotlin-trick-001/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>好的文章有时候不在于鸿篇巨制，而在于一目了然，有时候这种快餐小技巧更能帮助人，没有铺垫没有客套，直戳掌握知识的要害。所以从这篇开始会不间断的记录一些小技巧，文章已[饼干]开头的都是一篇短文。</p>\n<p>一些重复的工作，比如说我们在性能调优的时候经常用到的Trace，以下是一个实例：</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java:\"></a>Java:</h2><pre><code>Trace.beginSection(sectionName);\ndoSomeCalculation();\nTrace.endSection();\n</code></pre><h2 id=\"Annoying：\"><a href=\"#Annoying：\" class=\"headerlink\" title=\"Annoying：\"></a>Annoying：</h2><p>如果在每个地方都加入<strong>Trace.beginSection(sectionName)和Trace.endSection()</strong>会疯掉的，搞不好还忘记加Trace.endSection()。</p>\n<h2 id=\"When-it-comes-to-Kotlin：\"><a href=\"#When-it-comes-to-Kotlin：\" class=\"headerlink\" title=\"When it comes to Kotlin：\"></a>When it comes to Kotlin：</h2><p>利用kotlin的扩展方法特性，我们能够这样操作</p>\n<pre><code>inline fun trace(sectionName: String, body: () -&gt; Unit) {\n    Trace.beginSection(sectionName)\n    try {\n        body()\n    } finally {\n        Trace.endSection()\n    }\n}\n//and use it\ntrace(&quot;foo&quot;) {\n    doSomeCalculation()\n}\n</code></pre><p>这样我们就可以把Trace.beginSection(sectionName)和Trace.endSection()省略了。<br>甚至你还可以有返回值：</p>\n<pre><code>inline fun &lt;T&gt; trace(sectionName: String, body: () -&gt; T): T {\n    Trace.beginSection(sectionName)\n    try {\n        return body()\n    } finally {\n        Trace.endSection()\n    }\n}\n\n//and use it\nval result = trace(&quot;foo&quot;) {\n    doSomeCalculation()\n}\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>实际上这种方式是方法拓展，lambda带给我们的额便利，同样的技巧，相信你能应用到Trace以外更多的地方，相信你能接触到更好的用法。</strong></p>\n","categories":["programming"],"tags":["cookies","android","kotlin"]},{"title":"[点心]小清新加载等待控件","url":"http://halohoop.com/2017/06/04/roll_loading/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></p>\n<p>控件源码：<a href=\"https://github.com/halohoop/RollSquareView\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/RollSquareView</a></p>\n<p>正文</p>\n<p>背景<br>从锤子手机上看到的效果，锤子系统更新界面的入口按钮就是这个加载动画。</p>\n<p>效果图</p>\n<p><img src=\"/2017/06/04/roll_loading/roll_demo3.gif\" alt=\"demo1\"> 图1(效果图1)</p>\n<p><img src=\"/2017/06/04/roll_loading/roll_demo2.gif\" alt=\"demo2\"> 图2(效果图2)</p>\n<p>使用方式</p>\n<p><img src=\"/2017/06/04/roll_loading/roll_demo.png\" alt=\"demo3\"> 图3(使用说明图)</p>\n<ul>\n<li>half_rect_width:半个方块的宽度，单位dp</li>\n<li>rect_divier_width:方块之间间隔宽度，单位dp</li>\n<li>start_empty_position:初始空出的位置</li>\n<li>is_clockwise:是否顺时针旋转</li>\n<li>line_count:一行的数量，最少为3</li>\n<li>fix_round_cornor:固定的方框的圆角半径</li>\n<li>roll_round_cornor:旋转的方框的圆角半径，如果这两个圆角半径设置成不一样的值就会得到上面图1的效果，设置成一样就是图2.</li>\n<li>roll_when_show_stop_when_hide:是否自动开始自定旋转，如果设置为false，则需要手动调用startRoll()方法(下文会提到)才会开始运动，设置为true则设置View.Visibility就会自动开始旋转。</li>\n<li>square_color:方块的颜色。使用十六进制代码的形式（如：#333、#8e8e8e）</li>\n</ul>\n<p>讲解实现方法之前，首先要说明一下方格的排列方式是从左到右，从上到下，也就是如果line_count设置为3，那么方格的序号如下图：</p>\n<p><img src=\"/2017/06/04/roll_loading/notice1.png\" alt=\"demo3\"> 图4(序号排列说明)</p>\n<p>实现思路：<br>自定义控件最主要的就是如何去准备要展示给用户看的东西，东西有了之后，我们在onDraw方法里面按部就班的画出来就可以了。接下来就带大家来走一走我准备的整个过程。其实整个过程就像做菜，准备材料（准备数据），加调味料（处理初始数据），翻炒（编写逻辑），这一切都是在锅中完成的，这个锅就是我们的onDraw方法，我们把所有的一些都准备好，然后扔进锅（onDraw）里面。</p>\n<p>最终的绘制分为两步：</p>\n<ul>\n<li>绘制固定的方块</li>\n<li>绘制滚动的方块</li>\n</ul>\n<p>当运动的时候将固定的方框中的两个方块隐藏，然后让滚动的方块继承其中一个的位置，然后通过属性动画改变其位置的值以及旋转角度的值，最终调用invalidate()重绘让其动起来。</p>\n<p><img src=\"/2017/06/04/roll_loading/notice3.png\" alt=\"demo3\"> 图5(绘制原理图示)</p>\n<p>①（控件精髓就在此处）根据配置准备绘制的数据</p>\n<p>处理自定义属性：</p>\n<pre><code>private void initAttrs(Context context, AttributeSet attrs) {\n    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.RollSquareView);\n    //行列数\n    mLineCount = typedArray.getInteger(R.styleable.RollSquareView_line_count, 3);\n    //旋转的方块圆角\n    mRollRoundCornor = typedArray.getFloat(R.styleable.RollSquareView_roll_round_cornor, 10);\n    ...\n    其他属性省略，请大家看源码\n\n    //开始的空格位置\n    mStartEmptyPosition = typedArray.getInteger(R.styleable.RollSquareView_start_empty_position, 0);\n    if (isInsideTheRect(mStartEmptyPosition, mLineCount)) {\n        mStartEmptyPosition = 0;\n    }\n    //当动态滚动的时候实时更新的空格位置\n    mCurrEmptyPosition = mStartEmptyPosition;\n    typedArray.recycle();\n}\n</code></pre><p>当选择空格位置不是外围的方块序号的时候，自动选择0位置，判断是否外围一圈的算法如下，纯数学知识：</p>\n<p><img src=\"/2017/06/04/roll_loading/notice2.png\" alt=\"demo3\"> 图6(绿色框出来的就是非外围的方块)</p>\n<pre><code>private boolean isInsideTheRect(int pos, int lineCount) {\n    if (pos &lt; lineCount) {//是否第一行\n        return false;\n    } else if (pos &gt; (lineCount * lineCount - 1 - lineCount)) {//是否最后一行\n        return false;\n    } else if ((pos + 1) % lineCount == 0) {//是否右边\n        return false;\n    } else if (pos % lineCount == 0) {//是否左边\n        return false;\n    }\n    //四边都不在，那就是在内部了\n    return true;\n}\n</code></pre><p>初始化方块的方法：</p>\n<pre><code>private void initSquares(int startEmptyPosition) {\n    //创建mLineCount * mLineCount个方块\n    mFixSquares = new FixSquare[mLineCount * mLineCount];\n    for (int i = 0; i &lt; mFixSquares.length; i++) {\n        mFixSquares[i] = new FixSquare();\n        mFixSquares[i].index = i;\n        mFixSquares[i].isShow = startEmptyPosition == i ? false : true;\n        mFixSquares[i].rectF = new RectF();\n    }\n    //外圈链接起来\n    linkTheOuterSquare(mFixSquares, mIsClockwise);//下文讲解\n    //创建1个滚动方块\n    mRollSquare = new RollSquare();\n    mRollSquare.rectF = new RectF();\n    mRollSquare.isShow = false;\n}\n</code></pre><p>两种方块都使用内部类定义，代码如下：</p>\n<pre><code>private class FixSquare {\n    RectF rectF;//需要绘制的方块\n    int index;//所在的序号\n    boolean isShow;//是否需要绘制\n    FixSquare next;//指向下一个需要滚动的位置，顺时针和逆时针相反\n}\n\nprivate class RollSquare {\n    RectF rectF;//需要绘制的方块\n    int index;//所在的序号\n    boolean isShow;//是否需要绘制\n    /**\n     * 旋转中心坐标\n     */\n    float cx;//滚动的时候的旋转中心x\n    float cy;//滚动的时候的旋转中心y\n}\n</code></pre><p>我们可以看到固定的方块FixSquare中有一个next变量：</p>\n<pre><code>FixSquare next;//指向下一个需要滚动的位置，顺时针和逆时针相反\n</code></pre><p>因为我们需要将外围的一圈方块都链接起来，但是现在有一个问题就是外围的方块序号并不是按照0、1、2…排列的，因此我定义了一个next变量用于指定其下一个，这样一个接一个的就把外围连成一圈了。算法如下，可能第一次看这个方法的小伙伴需要看一小会儿，因为需要适配行数3个以上的需求，因此都是动态变化的，因此都是一些数学公式，这里篇幅有限不一一讲解，大家可以顺着注释看看规律就很容易理解了，这个方法的主要目的就是为了让每个FixSquare的“FixSquare next”都赋上值，最终将外围都连成一圈，不要忘记考虑顺逆时针isClockwise这个变量哦：</p>\n<pre><code>private void linkTheOuterSquare(FixSquare[] fixSquares, boolean isClockwise) {\n    int lineCount = (int) Math.sqrt(mFixSquares.length);\n    //连接第一行\n    for (int i = 0; i &lt; lineCount; i++) {\n        if (i % lineCount == 0) {//位于最左边\n            fixSquares[i].next = isClockwise ? fixSquares[i + lineCount] : fixSquares[i + 1];\n        } else if ((i + 1) % lineCount == 0) {//位于最右边\n            fixSquares[i].next = isClockwise ? fixSquares[i - 1] : fixSquares[i + lineCount];\n        } else {//中间\n            fixSquares[i].next = isClockwise ? fixSquares[i - 1] : fixSquares[i + 1];\n        }\n    }\n    //连接最后一行\n    for (int i = (lineCount - 1) * lineCount; i &lt; lineCount * lineCount; i++) {\n        if (i % lineCount == 0) {//位于最左边\n            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - lineCount];\n        } else if ((i + 1) % lineCount == 0) {//位于最右边\n            fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i - 1];\n        } else {//中间\n            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - 1];\n        }\n    }\n    //连接左边\n    for (int i = 1 * lineCount; i &lt;= (lineCount - 1) * lineCount; i += lineCount) {\n        if (i == (lineCount - 1) * lineCount) {//如果是左下角的一个\n            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - lineCount];\n            continue;\n        }\n        fixSquares[i].next = isClockwise ? fixSquares[i + lineCount] : fixSquares[i - lineCount];\n    }\n    //连接右边\n    for (int i = 2 * lineCount - 1; i &lt;= lineCount * lineCount - 1; i += lineCount) {\n        if (i == lineCount * lineCount - 1) {//如果是右下角的一个\n            fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i - 1];\n            continue;\n        }\n        fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i + lineCount];\n    }\n}\n</code></pre><p>固定方块的位置，分别使用fixFixSquarePosition和fixRollSquarePosition两个方法来固定FixSquare和RollSquare：</p>\n<pre><code>private void fixFixSquarePosition(FixSquare[] fixSquares, int cx, int cy, float dividerWidth, float halfSquareWidth) {\n    //确定第一个rect的位置\n    float squareWidth = halfSquareWidth * 2;\n    int lineCount = (int) Math.sqrt(fixSquares.length);\n    float firstRectLeft = 0;\n    float firstRectTop = 0;\n    if (lineCount % 2 == 0) {//偶数\n        int squareCountInAline = lineCount / 2;\n        int diviCountInAline = squareCountInAline - 1;\n        float firstRectLeftTopFromCenter = squareCountInAline * squareWidth\n                + diviCountInAline * dividerWidth\n                + dividerWidth / 2;\n        firstRectLeft = cx - firstRectLeftTopFromCenter;\n        firstRectTop = cy - firstRectLeftTopFromCenter;\n    } else {//奇数\n        int squareCountInAline = lineCount / 2;\n        int diviCountInAline = squareCountInAline;\n        float firstRectLeftTopFromCenter = squareCountInAline * squareWidth\n                + diviCountInAline * dividerWidth\n                + halfSquareWidth;\n        firstRectLeft = cx - firstRectLeftTopFromCenter;\n        firstRectTop = cy - firstRectLeftTopFromCenter;\n    }\n    for (int i = 0; i &lt; lineCount; i++) {//行\n        for (int j = 0; j &lt; lineCount; j++) {//列\n            if (i == 0) {\n                if (j == 0) {\n                    fixSquares[0].rectF.set(firstRectLeft, firstRectTop,\n                            firstRectLeft + squareWidth, firstRectTop + squareWidth);\n                } else {\n                    int currIndex = i * lineCount + j;\n                    fixSquares[currIndex].rectF.set(fixSquares[currIndex - 1].rectF);\n                    fixSquares[currIndex].rectF.offset(dividerWidth + squareWidth, 0);\n                }\n            } else {\n                int currIndex = i * lineCount + j;\n                fixSquares[currIndex].rectF.set(fixSquares[currIndex - lineCount].rectF);\n                fixSquares[currIndex].rectF.offset(0, dividerWidth + squareWidth);\n            }\n        }\n    }\n}\n\nprivate void fixRollSquarePosition(FixSquare[] fixSquares,\n                                   RollSquare rollSquare, int startEmptyPosition) {\n    FixSquare fixSquare = fixSquares[startEmptyPosition];\n    rollSquare.rectF.set(fixSquare.next.rectF);\n}\n</code></pre><p>对于方法fixFixSquarePosition：</p>\n<ul>\n<li>通过参数有控件的中点的x和y坐标，cx和cy，加上行数，方块的宽以及方块间隔;</li>\n<li>通过以上参数很容易就可以通过计算得出第0个方块的left和top值，分别是firstRectLeft和firstRectTop；</li>\n<li>因为行数可能是奇数也可能是偶数，所以分为奇数和偶数两种计算方式；</li>\n<li>然后我把第一行的方块都固定下来之后，剩下的方块只需要往下平移即可固定下来了；</li>\n<li>第一个for循环表示行，第二个表示列，都是简单的数学计数知识，不过多阐述。</li>\n</ul>\n<p>对于方法fixRollSquarePosition：</p>\n<ul>\n<li>因为我们已经从初始化的操作中知道哪一个位置是空的，startEmptyPosition；</li>\n<li>而且已经把外围的方块连成了环（通过next关联），上文的linkTheOuterSquare方法；</li>\n<li>因此可以很容易确定下来旋转的方块所要开始运动的初始位置。</li>\n</ul>\n<p>②两种运动，平移 和 90度旋转</p>\n<p>这里主要讲解一下思路，使用属性动画创建两个动画，一个是平移动画，一个是旋转动画，如下图，然后使用AnimatorSet将两个连接起来，同时运行。</p>\n<p><img src=\"/2017/06/04/roll_loading/notice4.png\" alt=\"demo3\">图7（平移动画）</p>\n<p><img src=\"/2017/06/04/roll_loading/notice5.png\" alt=\"demo3\">图8（旋转动画）</p>\n<ul>\n<li>由于篇幅有限，加之方法比较长，这里不贴出，感兴趣的朋友可以去原码查看：</li>\n<li>createTranslateValueAnimator方法 和 createRollValueAnimator方法；</li>\n<li>其中值得关注的点是：需要考虑顺逆时针，以及实时更新旋转方块的旋转中心，因为平移过程中旋转中心也会跟着改变的，因此需要改变RollSquare的cx和cy，具体的逻辑就在setRollSquareRotateCenter方法中，调用的时机当然就是在动画运动的过程中啦（见onAnimationUpdate）。</li>\n</ul>\n<p>③循环起来把</p>\n<ul>\n<li>通过调用startRoll方法，会创建一次动画，当动画结束的时候（onAnimationEnd），重新调用startRoll方法，以达到循环的目的。这里相信大家都明白，就跟handler循环发送消息一样。</li>\n<li>这里有一点需要注意的就是如果动画速度调的很快，那么会导致ValueAnimator动画对象频繁重复的创建，可能会有内存抖动的风险；因此建议使用者不要将速度调的太块，不过这个控件的后期的迭代我可能将这个动画对象换成始终只有一个ValueAnimator的情况。</li>\n</ul>\n<p>④停止条件</p>\n<ul>\n<li>在动画结束准备重新调用startRoll方法之前做一个变量判断，来控制是否需要循环调用，如下：</li>\n</ul>\n<pre><code>if (mAllowRoll) {\n    startRoll();\n}\n</code></pre><ul>\n<li>当我们调用stopRoll方法的时候，mAllowRoll会变为false，调用startRoll的时候，mAllowRoll会变为true；</li>\n</ul>\n<p>⑤最后，画出来</p>\n<pre><code>@Override\nprotected void onDraw(Canvas canvas) {\n    for (int i = 0; i &lt; mFixSquares.length; i++) {\n        if (mFixSquares[i].isShow) {\n            canvas.drawRoundRect(mFixSquares[i].rectF, mFixRoundCornor, mFixRoundCornor, mPaint);\n        }\n    }\n    if (mRollSquare.isShow) {\n        canvas.rotate(mIsClockwise ? mRotateDegree : -mRotateDegree, mRollSquare.cx, mRollSquare.cy);\n        canvas.drawRoundRect(mRollSquare.rectF, mRollRoundCornor, mRollRoundCornor, mPaint);\n    }\n}\n</code></pre><p>上文也有提到，最终的绘制分为两步：</p>\n<ol>\n<li>绘制固定的方块</li>\n<li>绘制滚动的方块；</li>\n</ol>\n<p>如果读者还有不明朗的地方，欢迎查看源码，并且给我提bug，一起为这个社区做出自己的微薄贡献。</p>\n","categories":["programming"],"tags":["android","effect","custom_view","snacks"]},{"title":"我觉得我的博文标签是这样分类的","url":"http://halohoop.com/1970/01/01/tags-notes/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<h4 id=\"露水-dewdrops\"><a href=\"#露水-dewdrops\" class=\"headerlink\" title=\"[露水]dewdrops\"></a>[露水]dewdrops</h4><ul>\n<li>琐事，生活体会，心灵鸡汤，更小的技巧等等…</li>\n</ul>\n<h4 id=\"饼干-cookies\"><a href=\"#饼干-cookies\" class=\"headerlink\" title=\"[饼干]cookies\"></a>[饼干]cookies</h4><ul>\n<li>小技巧，小知识点，等等…</li>\n</ul>\n<h4 id=\"点心-snacks\"><a href=\"#点心-snacks\" class=\"headerlink\" title=\"[点心]snacks\"></a>[点心]snacks</h4><ul>\n<li>再大一点的技巧，再大一点的知识点，等等…</li>\n</ul>\n<h4 id=\"大餐-meals\"><a href=\"#大餐-meals\" class=\"headerlink\" title=\"[大餐]meals\"></a>[大餐]meals</h4><ul>\n<li>需要花一些时间的东西，自定义控件，等等…</li>\n</ul>\n<h4 id=\"盛宴-feast\"><a href=\"#盛宴-feast\" class=\"headerlink\" title=\"[盛宴]feast\"></a>[盛宴]feast</h4><ul>\n<li>比较经典的东西，比如某个重要知识点的核心原码分析，等等…</li>\n</ul>\n<h4 id=\"仙丹-elixir\"><a href=\"#仙丹-elixir\" class=\"headerlink\" title=\"[仙丹]elixir\"></a>[仙丹]elixir</h4><ul>\n<li>鸿篇巨制，比如整个项目的分析，等等…</li>\n</ul>\n","categories":["notes"],"tags":["notes"]},{"title":"Hello World","url":"http://halohoop.com/1970/01/01/hello-world/","content":"<p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>\n<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","categories":["Hexo教程"],"tags":["tuts","hexo"]},{"title":"404 Not Found：该页无法显示","url":"http://halohoop.com//404.html","content":"<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\" homepageurl=\"http://halohoop.com\" homepagename=\"回主页\"></script>","categories":[],"tags":[]},{"title":"category","url":"http://halohoop.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://halohoop.com/css/personal-style.css","content":"@font-face {\n  font-family: \"Meiryo\";\n  src: url(\"/fonts/Meiryo.eot\");\n  /* IE9 */\n  src: url(\"/fonts/Meiryo.eot?#iefix\") format(\"embedded-opentype\"), /* IE6-IE8 */\n  url(\"/fonts/Meiryo.woff\") format(\"woff\"), /* chrome, firefox */\n  url(\"/fonts/Meiryo.ttf\") format(\"truetype\"), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url(\"/fonts/Meiryo.svg#Meiryo\") format(\"svg\");\n  /* iOS 4.1- */\n  font-style: normal;\n  font-weight: normal;\n}\nhtml.page-home {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-image: url('/images/bg.png');\n  background-color: transparent;\n  background-size: 0.5 0.5;\n  background-position: center center;\n  background-repeat: no-repeat;\n\n  /*background: linear-gradient( #1abc9c, transparent), linear-gradient( 90deg, skyblue, transparent), linear-gradient( -90deg, coral, transparent);\n  background-blend-mode: screen;*/\n\n  /*background: linear-gradient(to left, #5f2c82, #49a09d);*/\n  \n  /*background: linear-gradient(to right, white, #c7edcc, white);*/\n}\n\n\n/*html.page-home body {\n  background: transparent;\n}*/\n","categories":[],"tags":[]},{"title":"about","url":"http://halohoop.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://halohoop.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://halohoop.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://halohoop.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://halohoop.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"","url":"http://halohoop.com/halohoop_custom_datas/meals-kotlin_mvp_retrofit2_rxjava2_dagger2_demo/user1.json","content":"{\"total_count\":3,\"items\":[{\"login\":\"JakeWharton\",\"avatar_url\":\"https://avatars3.githubusercontent.com/u/66577?v=3\"},{\"login\":\"daimajia\",\"avatar_url\":\"https://avatars2.githubusercontent.com/u/2503423?v=3\"},{\"login\":\"hongyangAndroid\",\"avatar_url\":\"https://avatars3.githubusercontent.com/u/10704521?v=3\"},{\"login\":\"stormzhang\",\"avatar_url\":\"https://avatars0.githubusercontent.com/u/2267900?v=3\"},{\"login\":\"Trinea\",\"avatar_url\":\"https://avatars3.githubusercontent.com/u/1169522?v=3\"},{\"login\":\"wyouflf\",\"avatar_url\":\"https://avatars2.githubusercontent.com/u/2654372?v=3\"},{\"login\":\"singwhatiwanna\",\"avatar_url\":\"https://avatars0.githubusercontent.com/u/3346272?v=3\"},{\"login\":\"greenrobot\",\"avatar_url\":\"https://avatars3.githubusercontent.com/u/242242?v=3\"},{\"login\":\"loopj\",\"avatar_url\":\"https://avatars1.githubusercontent.com/u/104009?v=3\"}]}","categories":[],"tags":[]}]