[{"title":"[露水]小故事，大学问","url":"http://halohoop.com/2017/06/18/dewdrops-six_principle/","content":"<p>一个人骑着单车走了二里地，他老婆依偎在车后座，他们是去接小孩放学，小孩叫迪迪，然后扔下单车开车走了。</p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[饼干]ViewDragHelper.Callback.onEdgeLock是干嘛的么","url":"http://halohoop.com/2017/06/17/cookies-android_viewdraghelper_callback/","content":"<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>ViewDragHelper.Callback提供给我们很多回调，灰常方便，网上很多文章都非常棒和详细，如果你还不知道ViewDragHelper这个神器怎么用，那你先去看看这些<a href=\"http://46aae4d1e2371e4aa769798941cef698.devproxy.yunshipei.com/hbl_for_android/article/details/51485827\" target=\"_blank\" rel=\"external\">文章</a>，不然下文你也看不懂。</p>\n<p>有一个回调大家都没有在意，或者说描述的含糊不清，这里要说的回调就是：</p>\n<pre><code>@Override\npublic boolean onEdgeLock(int edgeFlags) {\n    return false;\n}\n</code></pre><p>默认是返回false，从方法字面上去理解，那就是边缘锁定，我试着判断一个边缘然后返回true看看，是否边缘拖拽就失效了呢，代码如下：</p>\n<pre><code>@Override\npublic boolean onEdgeLock(int edgeFlags) {\n    return (edgeFlags&amp;ViewDragHelper.EDGE_LEFT)==ViewDragHelper.EDGE_LEFT;\n}\n</code></pre><p>显然结果和我预料的并不一样，难道这个方法是要手动调用的咩？这个时候咋办呢，当然是看源码，记住，一切答案都在源码。</p>\n<p><img src=\"/2017/06/17/cookies-android_viewdraghelper_callback/demo0.png\" alt=\"demo0\"></p>\n<p>注意1278行，源码中确实调用了onEdgeLock，为什么没有跑到这句，这里有些线索，比如：</p>\n<ul>\n<li>absDelta &lt; absODelta * 0.5f，绝对值后新旧数据的比较</li>\n</ul>\n<p>但是线索还不够，那就往上爬，找到checkNewEdgeDrag方法被调用的地方。当是LEFT和RIGHT的时候传入的是dx和dy，而TOP和BOTTOM的时候传入的是dy和dx，dx和dy调换了位置，恍然大悟了。</p>\n<p><img src=\"/2017/06/17/cookies-android_viewdraghelper_callback/demo1.png\" alt=\"demo1\"></p>\n<p>不多说，我把代码直接翻译成中文：</p>\n<ul>\n<li>当想要锁住的是<strong>左</strong>或者<strong>右</strong>的时候，如果<strong>左右</strong>滑动的距离还没<strong>上下</strong>滑动的距离的一半多，那就走回调onEdgeLock()；</li>\n<li>当想要锁住的是<strong>上</strong>或者<strong>下</strong>的时候，如果<strong>上下</strong>滑动的距离还没<strong>左右</strong>滑动的距离的一半多，那就走回调onEdgeLock()；</li>\n</ul>\n<p>当我们开启了边缘锁定模式，像这样：</p>\n<pre><code>viewDragHelper.setEdgeTrackingEnabled(ViewDragHelper.EDGE_LEFT);//这里锁定左边\n</code></pre><p>之后，我们在左边缘<strong>上下</strong>滑动的时候，就能够走回调onEdgeLock方法了。</p>\n<p>看看红框框出来的部分，</p>\n<h2 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h2><ul>\n<li><p>微信边滑退出，识别是边滑的时候锁定只能是左右滑，而不能是上下滑。</p>\n<ul>\n<li>当然我们可以自己在别的ViewDragHelper.Callback的回调中做限制,比如clampViewPositionHorizontal和clampViewPositionVertical，但是，神经病啊，用原生的不用你写那么多的判断逻辑啊。</li>\n</ul>\n</li>\n<li><p>我写的Demo在这里，请享用：</p>\n<ul>\n<li><a href=\"https://github.com/halohoop/AndroidDigIn/blob/c4d530b5943ab79e7dd6dc3dbbff1f6a76e214be/app/src/main/java/com/halohoop/androiddigin/widgets/DragViewGroup.java\" target=\"_blank\" rel=\"external\">DragViewGroup.java</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>答案都在源码.</li>\n<li>Stay hungry stay foolish!</li>\n</ul>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n","categories":["programming"],"tags":["cookies","view","android","ViewDragHelper"]},{"title":"[饼干]FragmentManager的popBackStack的使用","url":"http://halohoop.com/2017/06/16/cookies-frag_manager_popstack/","content":"<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><ul>\n<li><p>用法：</p>\n<pre><code>//自己以上所有，不包括自己\ngetSupportFragmentManager().popBackStack(&quot;rt&quot;, 0);\n//自己以上所有，包括自己\ngetSupportFragmentManager().popBackStack(&quot;rt&quot;, 1);\n//最上层的一个\ngetSupportFragmentManager().popBackStack(null, 0);\n//最上层的一个\ngetSupportFragmentManager().popBackStack();\n//全部pop\ngetSupportFragmentManager().popBackStack(null, 1);\n</code></pre></li>\n<li><p>注意：</p>\n<ul>\n<li>popBackStack传入的第一个参数是addToBackStack(name)传入的参数，而不是Fragment的Tag；</li>\n<li>如果遇到两个name相同的连在一起的时候，两个移除，三个相同的就三个都移除…示例代码：<ul>\n<li>getFragmentManager().popBackStack(“rt”, 1); <ul>\n<li>也就是说，查找栈的顺序是先从后入栈的开始查找往下找，找到一个之后还继续找下一个如果还是一样的name就再找一个直到不是为止，然后将是的一并pop出栈。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实例代码Demo\"><a href=\"#实例代码Demo\" class=\"headerlink\" title=\"实例代码Demo\"></a>实例代码Demo</h2><p><a href=\"https://github.com/halohoop/AndroidDigIn#20fragmentmanager的popbackstack的使用\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/AndroidDigIn</a></p>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n<ul>\n<li>Stay hungry stay foolish!</li>\n</ul>\n","categories":["programming"],"tags":["cookies","android","Fragment"]},{"title":"[露水]adb无线调试","url":"http://halohoop.com/2017/06/15/dewdrops-adb_wifi/","content":"<p>条件：</p>\n<ul>\n<li>一台开发版手机</li>\n<li>两个命令：<ul>\n<li>adb tcpip 55555</li>\n<li>adb yourDevicesIp:55555</li>\n</ul>\n</li>\n</ul>\n<p>比如：</p>\n<pre><code>[win cmd]\nD:\\workspaces\\androidstudio\\project&gt;adb tcpip 55555\nD:\\workspaces\\androidstudio\\project&gt;adb connect 192.168.199.156:55555\nconnected to 192.168.199.156:55555\n</code></pre><p><strong>无线调试还支持 instant run 和 Debug 咧。</strong></p>\n<p><a href=\"https://developer.android.com/studio/command-line/adb.html#wireless\" target=\"_blank\" rel=\"external\">参考</a></p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[饼干]Kotlin Trick 003-滚吧工具类","url":"http://halohoop.com/2017/06/14/cookies-kotlin-trick-003/","content":"<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java:\"></a>Java:</h2><pre><code>class Utils {\n    public static char getLastChar(String str){\n        return str.charAt(s.length()-1);\n    }\n}\n</code></pre><p>调用:</p>\n<pre><code>char c = Utils.getLastChar(&quot;halohoop.com&quot;);//得到m\n</code></pre><h2 id=\"Annoying：\"><a href=\"#Annoying：\" class=\"headerlink\" title=\"Annoying：\"></a>Annoying：</h2><p>增加类</p>\n<h2 id=\"When-it-comes-to-Kotlin：\"><a href=\"#When-it-comes-to-Kotlin：\" class=\"headerlink\" title=\"When it comes to Kotlin：\"></a>When it comes to Kotlin：</h2><p>不需要增加额外的类。</p>\n<pre><code>//扩展属性\ninline val String.lastC: Char\n    get() = get(length - 1)\n</code></pre><p>或者：</p>\n<pre><code>//扩展方法\ninline fun String.getLastChar() : Char{\n    return get(length-1)\n}\n</code></pre><p>调用:</p>\n<pre><code>var c = &quot;halohoop.com&quot;.lastC//得到m\n</code></pre><p>或者</p>\n<pre><code>var c = &quot;halohoop.com&quot;.getLastChar()//得到m\n</code></pre>","categories":["programming"],"tags":["cookies","android","kotlin"]},{"title":"[饼干]Kotlin Trick 002-滚吧重载方法","url":"http://halohoop.com/2017/06/13/cookies-kotlin-trick-002/","content":"<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java:\"></a>Java:</h2><pre><code>void test(int i){\n}\nvoid test(String j){\n}\nvoid test(int i, String j){\n}\n</code></pre><p>调用:</p>\n<pre><code>test(1);\ntest(&quot;aaa&quot;);\ntest(1,&quot;aaa&quot;);\n</code></pre><h2 id=\"Annoying：\"><a href=\"#Annoying：\" class=\"headerlink\" title=\"Annoying：\"></a>Annoying：</h2><p>写太多重载了，眼都花了</p>\n<h2 id=\"When-it-comes-to-Kotlin：\"><a href=\"#When-it-comes-to-Kotlin：\" class=\"headerlink\" title=\"When it comes to Kotlin：\"></a>When it comes to Kotlin：</h2><pre><code>//一个足矣\nfun test(i:int = 0, j:String = &quot;&quot;){\n}\n</code></pre><p>调用:</p>\n<pre><code>test();//有默认值，可以不用传\ntest(1);\ntest(1,&quot;aaa&quot;);\ntest(j = &quot;aaa&quot;);//非第一个需要传递参数名字，这也能增加可读性\n</code></pre>","categories":["programming"],"tags":["cookies","android","kotlin"]},{"title":"[大餐]加快gradle构建速度","url":"http://halohoop.com/2017/06/13/meals-speedup_gradle_build/","content":"<p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></p>\n<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>AS中gradle构建一般可以分为三种，</p>\n<p>1.从0开始构建，Full Build；</p>\n<p>2.修改源代码后构建，之前构建过，Incremental build java change；</p>\n<p>3.修改资源文件后构建，之前构建过，Incremental build resource change。</p>\n<p>从这三方面其实都可以有切入点来进行提速，gradle插件3.0做了大改，优化了很多东西，包括gradle依赖系统以及缓存系统，这些都是直接影响构建速度的因素，整理了有10+个小技巧可以加快我们的构建速度，下面请听我一一道来。</p>\n<h2 id=\"正餐：\"><a href=\"#正餐：\" class=\"headerlink\" title=\"正餐：\"></a>正餐：</h2><h3 id=\"技巧1：使用最新版本的gradle插件\"><a href=\"#技巧1：使用最新版本的gradle插件\" class=\"headerlink\" title=\"技巧1：使用最新版本的gradle插件\"></a>技巧1：使用最新版本的gradle插件</h3><pre><code>buildscript {\n    repositories {\n        maven { url &apos;https://maven.google.com&apos; }\n        jcenter()\n    }\n    dependencies {\n        classpath &apos;com.android.tools.build:gradle:3.0.0-alpha1&apos;\n    }\n    ...\n}\n</code></pre><p>看到google.com之后，相信你应该知道要拿个“梯子”的，所以我说升级as最方便嘛，而现在gradle的版本已经更新到alpha1+了(现在是2017年06月12日)，根据谷歌官方只要是3.0+，也就是以2017I/O大会的版本开始就可以。</p>\n<h3 id=\"技巧2：避免使用legacy-multidex\"><a href=\"#技巧2：避免使用legacy-multidex\" class=\"headerlink\" title=\"技巧2：避免使用legacy multidex\"></a>技巧2：避免使用legacy multidex</h3><p>当app方法数量超过64k的时候就会编译失败，早期版本的构建系统按如下方式报告这一错误：</p>\n<pre><code>Conversion to Dalvik format failed:\nUnable to execute dex: method ID not in [0, 0xffff]: 65536\n</code></pre><p>较新版本的 Android 构建系统虽然显示的错误不同，但指示的是同一问题：</p>\n<pre><code>trouble writing output:\nToo many field references: 131000; max is 65536.\nYou may try using --multi-dex option.\n</code></pre><p>使用multidex分包处理是谷歌官方给我们提供的解决方案，由于分包被内置支持在5.0以及之后，当我们需要兼容的版本跨越5.0也就是api21的时候，比如说14–23，那么我们需要使用兼容库：</p>\n<pre><code>com.android.support:multidex:1.0.0\n</code></pre><p>使用兼容库能让我们的低版本的也进行分包处理，<a href=\"https://developer.android.com/studio/build/multidex.html#about\" target=\"_blank\" rel=\"external\">具体如何操作gradle需要配置什么Application需要如何设置</a>等不是本文重点，请各位自行谷歌、百度。</p>\n<p>根据谷歌官方描述，使用兼容库会明显拖慢构建，也就是如果你的调试机器版本低于5.0，又进行了分包处理，那么当你点击那个绿色构建按钮▶或者使用命令行gradlew构建的时候，那你可以先去吃一顿饭先了（Just kidding!）。</p>\n<p>所以我们在开发调试的时候尽量使用高版本的手机5.0+，等功能完成了，后面做兼容低版本的时候再使用低版本的手机进行调试。可能有人会说，我在开发功能的时候如果不实时调试低版本的兼容问题后期可能有问题，关于这一点，我想说的是一点是经验问题，经验足的人就是能够知道你这段代码写出来可能的结果，这是内功，不可言状，却又确实存在的能力，我见过这样的人，你没写出来他就能够知道运行的结果，另一点是我们需要相信google的兼容团队给我们的兼容方案是能够解决绝大部分的兼容问题的，我指的兼容方案是指使用appcompat、support等之类的兼容库。</p>\n<h3 id=\"技巧3：关闭multi-apk\"><a href=\"#技巧3：关闭multi-apk\" class=\"headerlink\" title=\"技巧3：关闭multi apk\"></a>技巧3：关闭multi apk</h3><p>如果你的项目需要编译出多个density或者多个abi（CPU架构）的APK，那么这也是开发构建的时候不需要做的操作，因为在你手上调试的机器只是一种density一种abi，因此我们在构建的时候可以将<a href=\"https://developer.android.com/studio/build/configure-apk-splits.html\" target=\"_blank\" rel=\"external\">multi-apk</a>的构建给去除。可以进行如下配置：</p>\n<pre><code>splits {\n    density {\n        //enable true\n        enable false\n        ...\n    }\n    abi {\n        //enable true\n        enable false\n        ...\n    }\n}\n</code></pre><p>但是显然这趟配置影响全局配置，后期还可能忘记改回来，更灵活一点的方式可以这样：</p>\n<pre><code>android {\n    ...\n    splits {\n        ...\n    ｝\n    if(project.hasProperty(&apos;HaloDevBuild&apos;)){\n        splits.abi.enable = false;\n        splits.density.enable = false;\n    }\n    ...\n}\n</code></pre><p>或者，可以更加细致一点：</p>\n<pre><code>android {\n    ...\n    splits {\n        ...\n    ｝\n    if(project.hasProperty(&apos;HaloDevBuild&apos;)){\n        splits.density.enable = false\n        splits.abi {\n            enable true\n            reset()\n            include &apos;arm64-v8a&apos; //select ABIs to build APKs for\n            universalApk false //whether generate an additional APK that contains all the ABIs\n        }\n        aaptOptions.cruncherEnabled = false\n    }\n    ...\n}\n</code></pre><p>注意project没有s，不是projects。<strong>并且这个判断的代码必须置于splits块的下面，否则就可能设置完之后就又被覆盖回来了</strong><br>“HaloDevBuild”属性的字符串我们可以自定义，在gradle写好这个判断之后，我们就可以在命令行编译了，命令如下：</p>\n<pre><code>./gradlew 项目名:变体 -PHaloDevBuild\n</code></pre><p>比如：</p>\n<pre><code>gradlew app:assembleDevelopmentDebug -PHaloDevBuild\n</code></pre><p>又或者可以构建顺带安装了：</p>\n<pre><code>gradlew demo:installdevelopmentDebug -PHaloDevBuild\n</code></pre><p>-P之后表示要传递的属性。当然我们如果需要在as中点击绿色构建按钮▶编译，那就要设置一下每次都要传入属性：</p>\n<p><img src=\"/2017/06/13/meals-speedup_gradle_build/demo0.png\" alt=\"demo0\"></p>\n<p>另外，我们可以这样获取Android手机CPU/ABI型号：</p>\n<pre><code>String CPU_ABI = android.os.Build.CPU_ABI;//过时了\nString CPU_ABIs[] = android.os.Build.SUPPORTED_ABIS;\n</code></pre><h3 id=\"技巧4：使用最少的资源打包\"><a href=\"#技巧4：使用最少的资源打包\" class=\"headerlink\" title=\"技巧4：使用最少的资源打包\"></a>技巧4：使用最少的资源打包</h3><p>和上面的思路一样，我们开发调试的时候只需要用到一种语言和一套资源文件。所以我们打包的时候不需要将所有的东西都放到这个调试的apk中。我们可以采用<a href=\"https://developer.android.com/studio/build/build-variants.html\" target=\"_blank\" rel=\"external\">定义变体</a>的方式来完成，注意下面的resConfigs属性指定了要保留的素材资源文件和语言资源文件。</p>\n<pre><code>android {\n    ...\n    flavorDimensions &quot;dev&quot;\n    productFlavors {\n        development {\n            dimension &quot;dev&quot;\n            resConfigs &quot;en&quot;, &quot;xxhdpi&quot;\n            ...\n        }\n    }\n}\n</code></pre><h3 id=\"技巧5-关闭aapt对png的优化\"><a href=\"#技巧5-关闭aapt对png的优化\" class=\"headerlink\" title=\"技巧5:关闭aapt对png的优化\"></a>技巧5:关闭aapt对png的优化</h3><p>aapt打包时候对资源图片的处理也会耗时，这里主要针对PNG，我们可以暂时关闭这种处理，还是用到上面的技巧，gradle配置如下：</p>\n<pre><code>android {\n    ...\n    if(projects.hasProperty(&apos;HaloDevBuild&apos;)){\n        splits.abi.enable = false;\n        splits.density.enable = false;\n        aaptOptions.cruncherEnabled = false\n    }\n    ...\n}\n</code></pre><p>当然如果我们将PNG转为webP也可以是一种优化方案。as2.3+支持直接转换，右键直接png图片选则convert to webP。当然webP是有版本要求的，所以请注意其用法，非本文重点自行百度了解。</p>\n<h3 id=\"技巧6：使用instant-run\"><a href=\"#技巧6：使用instant-run\" class=\"headerlink\" title=\"技巧6：使用instant run\"></a>技巧6：使用instant run</h3><p>多使用instant run，根据谷歌的描述，as3.0和2.0的instant run有巨大的差别，做了很多的优化，instant run要求调试的机器必须要在api21或者以上，而不是你的项目最小版本要在21或者以上。还有一点就是使用instant run的时候，如果我们首次构建是从0开始的，那么会比不使用instant run慢一点，因为需要为后面的instant run的冷热交换去准备一些额外的东西，然而如果后面一直都使用instant run，那么首次构建的延缓的时间就能很快被挽回来。</p>\n<h3 id=\"技巧7：避免写一些不必要的更改\"><a href=\"#技巧7：避免写一些不必要的更改\" class=\"headerlink\" title=\"技巧7：避免写一些不必要的更改\"></a>技巧7：避免写一些不必要的更改</h3><p>有些开发者为了方便会直接使用时间戳来作为每次构建的版本号（或者是自己的一套计算算法），像这样：</p>\n<pre><code>def buildDataTime = new Date().format(&apos;yyMMddHHmm&apos;).toInteger()\nandroid {\n    ...\n    defaultConfig {\n        versionCode buildDateTime\n        ...\n    }\n}\n</code></pre><p>这个一定程度上方便了我们，但是对于gradle构建系统来说，这不是好事。由于每次版本号都有修改，这就直接导致清单文件Manifest的更改。而清单文件的修改势必会趋势构建系统重新审视整个项目情况，这会增加很多额外的时间，这在开发调试的时候根本没有必要。</p>\n<p>还是利用上面的技巧，我们可以这样：</p>\n<pre><code>def buildDataTime = project.hasProperty(&apos;HaloDevBuild&apos;)? 100 : new Date().format(&apos;yyMMddHHmm&apos;).toInteger()\nandroid {\n    ...\n    defaultConfig {\n        versionCode buildDateTime\n        ...\n    }\n}\n</code></pre><h3 id=\"技巧8：类库不要使用动态的版本\"><a href=\"#技巧8：类库不要使用动态的版本\" class=\"headerlink\" title=\"技巧8：类库不要使用动态的版本\"></a>技巧8：类库不要使用动态的版本</h3><p>项目中可能会这样配置：</p>\n<pre><code>dependencies {\n    ...\n    compile &apos;com.android.support:appcompat-v7:+&apos;\n}\n</code></pre><p>这个加号+，导致gradle每次构建都要检查新的版本。即使你希望每次都用最新但是还是不好，因为库可能已经有很大的变化了，但是你是基于旧版开发的，所以为了安全不要这样设置。其实这和我们coding还是一样的道理，我们码代码的时候肯定会考虑如何能让别人的修改不影响到我们自己的，因此这个加号使不得，使不得。</p>\n<h3 id=\"技巧9：查看jvm使用的内存是否合适\"><a href=\"#技巧9：查看jvm使用的内存是否合适\" class=\"headerlink\" title=\"技巧9：查看jvm使用的内存是否合适\"></a>技巧9：查看jvm使用的内存是否合适</h3><p><img src=\"/2017/06/13/meals-speedup_gradle_build/demo1.png\" alt=\"demo1\"></p>\n<p>我一般设置为2g，这个根据项目的不同可能会有不同效果，所以可以试着稍微调整一下。</p>\n<h3 id=\"技巧10：打开gradle新的缓存机制\"><a href=\"#技巧10：打开gradle新的缓存机制\" class=\"headerlink\" title=\"技巧10：打开gradle新的缓存机制\"></a>技巧10：打开gradle新的缓存机制</h3><p>我们可以通过一个设置使用这种新的缓存机制，如下：</p>\n<pre><code>//在gradle.properties中+一行\norg.gradle.caching=true\n</code></pre><p>文章开头也提到过，Gradle 3.5（现在20170612的gradle版本已经4.0了）新的机制，可以缓存所有任务的输出。这个和as2.3时候介绍的build 缓存不一样，build 缓存只缓存预dex的外部libs。而任何时候的构建缓存其实都是可复用的，比如切换分支之后，还可以用其他分支时候的构建缓存。</p>\n<p>当然，根据谷歌官方描述，这个设置的背后还有很多需要完善的地方，使用的同时，我们可以有更多后期优化的期待。</p>\n<h3 id=\"技巧11：使用新的依赖机制\"><a href=\"#技巧11：使用新的依赖机制\" class=\"headerlink\" title=\"技巧11：使用新的依赖机制\"></a>技巧11：使用新的依赖机制</h3><p>按照官方的描述，gradle3.0之前，构建系统的依赖关系被认为是一种完全错误的方式，举一个例子：</p>\n<p>app依赖了库libX，库libX又依赖库libY。</p>\n<p>app：</p>\n<pre><code>compile &apos;libX&apos;\n</code></pre><p>libX：</p>\n<pre><code>compile &apos;libY&apos;\n</code></pre><p>如果在app中调用了libY的方法，这个时候如果libY中的方法做了改变，那么由于libY被和libX和app都有依赖被依赖关系，这时候如果构建libY势必会导致libX和app也重新构建。</p>\n<p>这应该是个完全错误的依赖方式，正确的方式应该是既然app只依赖了libX那就不应该知道libY中的api，然而这在构建系统3.0（gradle插件）之前都是这样存在的，因此3.0做了改变，引入了新的依赖形式，api和implementation来替换compile。</p>\n<ul>\n<li>implementation：表示我依赖你，但是你的api不会被我重新分享出去了。</li>\n<li>api：表示我依赖你，但是你的api会被我重新分享出去了。</li>\n</ul>\n<p>那么在看上面的例子就变成了：</p>\n<p>app：</p>\n<pre><code>implementation &apos;libX&apos;\n</code></pre><p>libX：</p>\n<pre><code>api &apos;libY&apos;\n</code></pre><p>由于存在之前的这种依赖传递的错误机制，因此我们项目中很可能就出现了这种依赖传递之后导致一个小修改就把所有库都构建一遍的情况，因此我们花一些时间将一些库的compile都替换成api和impementation对我们是有好处的，一来有效缩短构建时间，而来真正搞清楚项目中依赖的情况，那些api需要依赖传递，哪些不需要。</p>\n<p>当然我们还是可以继续使用compile，不过这种方式已经是过时的了，我们只要更新了最新插件，那么新建了项目就会发现所有的compile都会被换成了implementation。相关的修改还有androidTestImplementation和testImplementation，对应的是原来的androidTestCompile和testCompile。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>根据上述技巧，我写了一个小demo：</p>\n<p><a href=\"https://github.com/halohoop/SpeedUpGradleBuild2\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/SpeedUpGradleBuild2</a></p>\n<ul>\n<li>Stay hungry stay foolish!</li>\n</ul>\n","categories":["programming"],"tags":["android","meals","gradle","构建"]},{"title":"[大餐]开发摘记1--我的Fragment通信的框架","url":"http://halohoop.com/2017/06/09/meals-android-fishing/","content":"<p>如果把通信比作钓鱼，如果每次都有鱼上钩，那么我想可以分为以下四种：</p>\n<ul>\n<li>1.鱼钩上<strong>不钩</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线断了，连线带钩和鱼都没了。</li>\n<li>2.鱼钩上<strong>钩上</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线断了，连线带钩和鱼带饵料都没了。</li>\n<li>3.鱼钩上<strong>不钩</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线<strong>没断</strong>，连线带钩和鱼带饵料都<strong>拉回来</strong>了。</li>\n<li>4.鱼钩上<strong>钩上</strong>饵料，然后抛出去，钩到鱼了，这时候鱼线<strong>没断</strong>，连线带钩和鱼带饵料都<strong>拉回来</strong>了。</li>\n</ul>\n<p>其实这四种就可以对应着四种不同的通信：</p>\n<ul>\n<li>1.A向发了一个<strong>空的通知</strong>让B响应了，A不需要知道B是否响应(鱼线断了)。</li>\n<li>2.A向发了一个<strong>携带参数的通知</strong>让B响应了，A不需要知道B是否响应(鱼线断了)。</li>\n<li>3.A向发了一个<strong>空的通知</strong>让B响应了，A需要知道B是否响应，最终A得到了B响应结果(鱼线完好，成功回收)。</li>\n<li>4.A向发了一个<strong>携带参数的通知</strong>让B响应了，A需要知道B是否响应，最终A得到了B响应结果(鱼线完好，成功回收)。</li>\n</ul>\n<p>再说的简单一点，那就是：</p>\n<ul>\n<li>1.调用“void func()”方法，无参无返回值。</li>\n<li>2.调用“void func(P p)”方法，有参无返回值。</li>\n<li>3.调用“R func()”方法，无参有返回值。</li>\n<li>4.调用“R func(P p)”方法，有参有返回值。</li>\n</ul>\n<p>因为通信无非就是这四种方法，那么就可以抽象出来的这四类方法的类，如果使用四个容器装着，在合适的时候往里添加，并且在合适的时候取出来调用，那么势必可以变成一个解耦通信框架。</p>\n<p>后面会陆续记录开发这个小框架的心路历程。</p>\n<hr>\n<p><img src=\"/2017/06/09/meals-android-fishing/demo0.png\" alt=\"\"></p>\n<p>项目地址：</p>\n<p><a href=\"https://github.com/halohoop/Fishing\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/Fishing</a></p>\n<p>已经可以正常使用了。</p>\n","categories":["programming"],"tags":["view","android","meals","开发摘记"]},{"title":"[露水]你知道卫语句不","url":"http://halohoop.com/2017/06/08/dewdrops-weiyuju/","content":"<h3 id=\"卫语句\"><a href=\"#卫语句\" class=\"headerlink\" title=\"卫语句\"></a>卫语句</h3><p>在<a href=\"http://halohoop.com/2017/06/08/dewdrops-weiyuju/《阿里巴巴Java开发手册》.pdf\">《阿里巴巴Java开发手册》.pdf</a>中的15页有提到“卫语句”，如下图。</p>\n<p><img src=\"/2017/06/08/dewdrops-weiyuju/demo0.png\" alt=\"demo0\"></p>\n<p>说的是：</p>\n<h3 id=\"我们不要这样写：\"><a href=\"#我们不要这样写：\" class=\"headerlink\" title=\"我们不要这样写：\"></a>我们不要这样写：</h3><pre><code>if(){\n\n}else if(){\n\n}else if(){\n\n}...\n</code></pre><h3 id=\"而要这样写\"><a href=\"#而要这样写\" class=\"headerlink\" title=\"而要这样写\"></a>而要这样写</h3><pre><code>if(){\n    return;\n}\nif(){\n    return;\n}\nif(){\n    return;\n}\n</code></pre><p>虽然不是很明白更深层的原因，但是我表示对后面那一句“或者状态模式来实现”很有感触，因为正在做的一个小框架就打算使用状态模式来摒弃一堆的if-else判断。</p>\n","categories":["programming"],"tags":["dewdrops"]},{"title":"[露水]客观，有时候需要精分","url":"http://halohoop.com/2017/06/08/dewdrops-be_objective/","content":"<link href=\"/style.css\" rel=\"stylesheet\" type=\"text/css\"><script src=\"/crypto-js.js\"></script><script src=\"/mcommon.js\"></script><script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script> <div id=\"security\"> <div> <div class=\"input-container\"> <input type=\"password\" class=\"form-control\" id=\"pass\" placeholder=\" Password to read. \"/> <label for=\"pass\"> Password to read. </label> <div class=\"bottom-line\"></div> </div> </div> </div> <div id=\"encrypt-blog\" style=\"display:none\"> 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 </div>","categories":["tricks"],"tags":["dewdrops"]},{"title":"[露水]多看书有多重要","url":"http://halohoop.com/2017/06/06/dewdrops-importance-of-books/","content":"<p>多看书有多重要，为了拓展思维，在大脑留下更多的种子，也许你没有全部记住，但是你留下了种子，日后接触到相关的内容(肥料)的时候，你可以快速的回来生根发芽。</p>\n","categories":["tricks"],"tags":["dewdrops"]},{"title":"[饼干]安卓小秘密-不扩大view宽高增加其可触控范围","url":"http://halohoop.com/2017/06/06/cookies-android-touchdelegate/","content":"<h2 id=\"开门撞山：\"><a href=\"#开门撞山：\" class=\"headerlink\" title=\"开门撞山：\"></a>开门撞山：</h2><p>今天我要记录的是<strong>TouchDelegate</strong>，有很多人应该都不知道还有这个东西，知道的孩子都没你们事了，都散了散了吧，不知道的请往下看。其实也不算什么秘密，只要你仔细的走过神迹一样的事件分发的源码，很容易发现的。</p>\n<h2 id=\"场景：\"><a href=\"#场景：\" class=\"headerlink\" title=\"场景：\"></a>场景：</h2><p>如下图，有这样一个场景，View a 需要有这么大，比如可以是一个按钮，UI要求显示View a的黑框部分，但是为了更好的用户体验，我们一般会增大其触控范围，比如点击绿框中都能够触发a的事件，咋做？（说好的不卖关子的呢？）</p>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo0.png\" alt=\"demo0\"></p>\n<h2 id=\"Don’t-do\"><a href=\"#Don’t-do\" class=\"headerlink\" title=\"Don’t do:\"></a>Don’t do:</h2><ul>\n<li>增加a的Padding?<ul>\n<li>后期如果修改bgColor，那么不好了，绿色框内全变色。</li>\n</ul>\n</li>\n<li>套多一层透明的FrameLayout？<ul>\n<li>增加布局复杂度，我TM一脚飞死你。 </li>\n</ul>\n</li>\n<li>自定义view限制绘制区域？<ul>\n<li>写完了？你很棒！但是你可以收拾包袱走人了。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"What-should-do-How-to-use-TouchDelegate-：\"><a href=\"#What-should-do-How-to-use-TouchDelegate-：\" class=\"headerlink\" title=\"What should do (How to use TouchDelegate)：\"></a>What should do (How to use TouchDelegate)：</h2><p>要学会站在巨人的肩膀，要知道，<strong>“你遇到的，巨人也会遇到”</strong>，巨人给我们留下了<strong>TouchDelegate</strong></p>\n<h3 id=\"直接上菜：\"><a href=\"#直接上菜：\" class=\"headerlink\" title=\"直接上菜：\"></a>直接上菜：</h3><p>注意方法ViewGroup.setTouchDelegate(Rect,View)</p>\n<p>以下代码出自我一个自定义View—<a href=\"https://github.com/halohoop/UsoppBubble/blob/master/lib/src/main/java/com/halohoop/usoppbubble/widget/UsoppBubble.java\" target=\"_blank\" rel=\"external\">UsoppBubble.java</a></p>\n<pre><code>@Override\nprotected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n    super.onLayout(changed, left, top, right, bottom);\n    if (changed) {\n        float largedSize = (bottom - top) * mTouchAreaLargerRatio;//乘以放大倍数\n        int deltaY = (int) (largedSize - (bottom - top));\n        int deltaX = largedSize &gt; (right - left) ? (int) (largedSize - (right - left)) : 0;\n        ViewGroup vg = (ViewGroup) getParent();\n        Rect rect = new Rect(left - deltaX, top - deltaY, right + deltaX, bottom + deltaY);\n        //构建出来的Rect对象就相当于绿色框框，而this就是这个view的实例。\n        vg.setTouchDelegate(new TouchDelegate(rect, this));\n    }\n}\n</code></pre><p>相信上述代码是极度容易的，ViewGroup.setTouchDelegate(Rect,View)接受两个参数：</p>\n<ul>\n<li>可触控区域。</li>\n<li>谁(哪个子view)需要用这个可触控区域。</li>\n</ul>\n<h2 id=\"实际应用场景\"><a href=\"#实际应用场景\" class=\"headerlink\" title=\"实际应用场景\"></a>实际应用场景</h2><ul>\n<li>QQ消息气泡可触控区域</li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo1.png\" alt=\"demo1\"></p>\n<ul>\n<li>当然我也模仿qq做了一个<a href=\"https://github.com/halohoop/UsoppBubble\" target=\"_blank\" rel=\"external\">自己的消息气泡版本</a></li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo2.gif\" alt=\"demo2\"></p>\n<ul>\n<li>小米贴边悬浮球点击唤醒</li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo3.png\" alt=\"demo3\"></p>\n<ul>\n<li>锤子的闪念胶囊贴边点击唤醒</li>\n</ul>\n<p><img src=\"/2017/06/06/cookies-android-touchdelegate/demo4.png\" alt=\"demo4\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>View.setTouchDelegate(Rect,View)，这句还不够吗？还要我怎样？</li>\n<li>你遇到的，巨人也会遇到，如果换位思考一下，你就是“巨人”，那么子View获取到的触摸事件是从ViewGroup分发下来的，那么如果在分发之前加一些条件判断，比如区域什么的，那么TouchDelegate这玩意儿是不是就出来了呢？</li>\n<li>Stay hungry stay foolish!</li>\n</ul>\n<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>\n<hr>\n<p>确保这文章被看完了，我在上面留了一个无伤大雅的bug，不知道有人发现没有，那就是：</p>\n<p><em>setTouchDelegate其实是View的方法。而ViewGroup : View，无伤大雅。</em></p>\n","categories":["programming"],"tags":["cookies","view","android"]},{"title":"[饼干]Kotlin Trick 001-省略一些重复的工作","url":"http://halohoop.com/2017/06/05/cookies-kotlin-trick-001/","content":"<p>好的文章有时候不在于鸿篇巨制，而在于一目了然，有时候这种快餐小技巧更能帮助人，没有铺垫没有客套，直戳掌握知识的要害。所以从这篇开始会不间断的记录一些小技巧，文章已[饼干]开头的都是一篇短文。</p>\n<p>一些重复的工作，比如说我们在性能调优的时候经常用到的Trace，以下是一个实例：</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java:\"></a>Java:</h2><pre><code>Trace.beginSection(sectionName);\ndoSomeCalculation();\nTrace.endSection();\n</code></pre><h2 id=\"Annoying：\"><a href=\"#Annoying：\" class=\"headerlink\" title=\"Annoying：\"></a>Annoying：</h2><p>如果在每个地方都加入<strong>Trace.beginSection(sectionName)和Trace.endSection()</strong>会疯掉的，搞不好还忘记加Trace.endSection()。</p>\n<h2 id=\"When-it-comes-to-Kotlin：\"><a href=\"#When-it-comes-to-Kotlin：\" class=\"headerlink\" title=\"When it comes to Kotlin：\"></a>When it comes to Kotlin：</h2><p>利用kotlin的扩展方法特性，我们能够这样操作</p>\n<pre><code>inline fun trace(sectionName: String, body: () -&gt; Unit) {\n    Trace.beginSection(sectionName)\n    try {\n        body()\n    } finally {\n        Trace.endSection()\n    }\n}\n//and use it\ntrace(&quot;foo&quot;) {\n    doSomeCalculation()\n}\n</code></pre><p>这样我们就可以把Trace.beginSection(sectionName)和Trace.endSection()省略了。<br>甚至你还可以有返回值：</p>\n<pre><code>inline fun &lt;T&gt; trace(sectionName: String, body: () -&gt; T): T {\n    Trace.beginSection(sectionName)\n    try {\n        return body()\n    } finally {\n        Trace.endSection()\n    }\n}\n\n//and use it\nval result = trace(&quot;foo&quot;) {\n    doSomeCalculation()\n}\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>实际上这种方式是方法拓展，lambda带给我们的额便利，同样的技巧，相信你能应用到Trace以外更多的地方，相信你能接触到更好的用法。</strong></p>\n","categories":["programming"],"tags":["cookies","android","kotlin"]},{"title":"[点心]小清新加载等待控件","url":"http://halohoop.com/2017/06/04/roll_loading/","content":"<p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></p>\n<p>控件源码：<a href=\"https://github.com/halohoop/RollSquareView\" target=\"_blank\" rel=\"external\">https://github.com/halohoop/RollSquareView</a></p>\n<p>正文</p>\n<p>背景<br>从锤子手机上看到的效果，锤子系统更新界面的入口按钮就是这个加载动画。</p>\n<p>效果图</p>\n<p><img src=\"/2017/06/04/roll_loading/roll_demo3.gif\" alt=\"demo1\"> 图1(效果图1)</p>\n<p><img src=\"/2017/06/04/roll_loading/roll_demo2.gif\" alt=\"demo2\"> 图2(效果图2)</p>\n<p>使用方式</p>\n<p><img src=\"/2017/06/04/roll_loading/roll_demo.png\" alt=\"demo3\"> 图3(使用说明图)</p>\n<ul>\n<li>half_rect_width:半个方块的宽度，单位dp</li>\n<li>rect_divier_width:方块之间间隔宽度，单位dp</li>\n<li>start_empty_position:初始空出的位置</li>\n<li>is_clockwise:是否顺时针旋转</li>\n<li>line_count:一行的数量，最少为3</li>\n<li>fix_round_cornor:固定的方框的圆角半径</li>\n<li>roll_round_cornor:旋转的方框的圆角半径，如果这两个圆角半径设置成不一样的值就会得到上面图1的效果，设置成一样就是图2.</li>\n<li>roll_when_show_stop_when_hide:是否自动开始自定旋转，如果设置为false，则需要手动调用startRoll()方法(下文会提到)才会开始运动，设置为true则设置View.Visibility就会自动开始旋转。</li>\n<li>square_color:方块的颜色。使用十六进制代码的形式（如：#333、#8e8e8e）</li>\n</ul>\n<p>讲解实现方法之前，首先要说明一下方格的排列方式是从左到右，从上到下，也就是如果line_count设置为3，那么方格的序号如下图：</p>\n<p><img src=\"/2017/06/04/roll_loading/notice1.png\" alt=\"demo3\"> 图4(序号排列说明)</p>\n<p>实现思路：<br>自定义控件最主要的就是如何去准备要展示给用户看的东西，东西有了之后，我们在onDraw方法里面按部就班的画出来就可以了。接下来就带大家来走一走我准备的整个过程。其实整个过程就像做菜，准备材料（准备数据），加调味料（处理初始数据），翻炒（编写逻辑），这一切都是在锅中完成的，这个锅就是我们的onDraw方法，我们把所有的一些都准备好，然后扔进锅（onDraw）里面。</p>\n<p>最终的绘制分为两步：</p>\n<ul>\n<li>绘制固定的方块</li>\n<li>绘制滚动的方块</li>\n</ul>\n<p>当运动的时候将固定的方框中的两个方块隐藏，然后让滚动的方块继承其中一个的位置，然后通过属性动画改变其位置的值以及旋转角度的值，最终调用invalidate()重绘让其动起来。</p>\n<p><img src=\"/2017/06/04/roll_loading/notice3.png\" alt=\"demo3\"> 图5(绘制原理图示)</p>\n<p>①（控件精髓就在此处）根据配置准备绘制的数据</p>\n<p>处理自定义属性：</p>\n<pre><code>private void initAttrs(Context context, AttributeSet attrs) {\n    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.RollSquareView);\n    //行列数\n    mLineCount = typedArray.getInteger(R.styleable.RollSquareView_line_count, 3);\n    //旋转的方块圆角\n    mRollRoundCornor = typedArray.getFloat(R.styleable.RollSquareView_roll_round_cornor, 10);\n    ...\n    其他属性省略，请大家看源码\n\n    //开始的空格位置\n    mStartEmptyPosition = typedArray.getInteger(R.styleable.RollSquareView_start_empty_position, 0);\n    if (isInsideTheRect(mStartEmptyPosition, mLineCount)) {\n        mStartEmptyPosition = 0;\n    }\n    //当动态滚动的时候实时更新的空格位置\n    mCurrEmptyPosition = mStartEmptyPosition;\n    typedArray.recycle();\n}\n</code></pre><p>当选择空格位置不是外围的方块序号的时候，自动选择0位置，判断是否外围一圈的算法如下，纯数学知识：</p>\n<p><img src=\"/2017/06/04/roll_loading/notice2.png\" alt=\"demo3\"> 图6(绿色框出来的就是非外围的方块)</p>\n<pre><code>private boolean isInsideTheRect(int pos, int lineCount) {\n    if (pos &lt; lineCount) {//是否第一行\n        return false;\n    } else if (pos &gt; (lineCount * lineCount - 1 - lineCount)) {//是否最后一行\n        return false;\n    } else if ((pos + 1) % lineCount == 0) {//是否右边\n        return false;\n    } else if (pos % lineCount == 0) {//是否左边\n        return false;\n    }\n    //四边都不在，那就是在内部了\n    return true;\n}\n</code></pre><p>初始化方块的方法：</p>\n<pre><code>private void initSquares(int startEmptyPosition) {\n    //创建mLineCount * mLineCount个方块\n    mFixSquares = new FixSquare[mLineCount * mLineCount];\n    for (int i = 0; i &lt; mFixSquares.length; i++) {\n        mFixSquares[i] = new FixSquare();\n        mFixSquares[i].index = i;\n        mFixSquares[i].isShow = startEmptyPosition == i ? false : true;\n        mFixSquares[i].rectF = new RectF();\n    }\n    //外圈链接起来\n    linkTheOuterSquare(mFixSquares, mIsClockwise);//下文讲解\n    //创建1个滚动方块\n    mRollSquare = new RollSquare();\n    mRollSquare.rectF = new RectF();\n    mRollSquare.isShow = false;\n}\n</code></pre><p>两种方块都使用内部类定义，代码如下：</p>\n<pre><code>private class FixSquare {\n    RectF rectF;//需要绘制的方块\n    int index;//所在的序号\n    boolean isShow;//是否需要绘制\n    FixSquare next;//指向下一个需要滚动的位置，顺时针和逆时针相反\n}\n\nprivate class RollSquare {\n    RectF rectF;//需要绘制的方块\n    int index;//所在的序号\n    boolean isShow;//是否需要绘制\n    /**\n     * 旋转中心坐标\n     */\n    float cx;//滚动的时候的旋转中心x\n    float cy;//滚动的时候的旋转中心y\n}\n</code></pre><p>我们可以看到固定的方块FixSquare中有一个next变量：</p>\n<pre><code>FixSquare next;//指向下一个需要滚动的位置，顺时针和逆时针相反\n</code></pre><p>因为我们需要将外围的一圈方块都链接起来，但是现在有一个问题就是外围的方块序号并不是按照0、1、2…排列的，因此我定义了一个next变量用于指定其下一个，这样一个接一个的就把外围连成一圈了。算法如下，可能第一次看这个方法的小伙伴需要看一小会儿，因为需要适配行数3个以上的需求，因此都是动态变化的，因此都是一些数学公式，这里篇幅有限不一一讲解，大家可以顺着注释看看规律就很容易理解了，这个方法的主要目的就是为了让每个FixSquare的“FixSquare next”都赋上值，最终将外围都连成一圈，不要忘记考虑顺逆时针isClockwise这个变量哦：</p>\n<pre><code>private void linkTheOuterSquare(FixSquare[] fixSquares, boolean isClockwise) {\n    int lineCount = (int) Math.sqrt(mFixSquares.length);\n    //连接第一行\n    for (int i = 0; i &lt; lineCount; i++) {\n        if (i % lineCount == 0) {//位于最左边\n            fixSquares[i].next = isClockwise ? fixSquares[i + lineCount] : fixSquares[i + 1];\n        } else if ((i + 1) % lineCount == 0) {//位于最右边\n            fixSquares[i].next = isClockwise ? fixSquares[i - 1] : fixSquares[i + lineCount];\n        } else {//中间\n            fixSquares[i].next = isClockwise ? fixSquares[i - 1] : fixSquares[i + 1];\n        }\n    }\n    //连接最后一行\n    for (int i = (lineCount - 1) * lineCount; i &lt; lineCount * lineCount; i++) {\n        if (i % lineCount == 0) {//位于最左边\n            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - lineCount];\n        } else if ((i + 1) % lineCount == 0) {//位于最右边\n            fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i - 1];\n        } else {//中间\n            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - 1];\n        }\n    }\n    //连接左边\n    for (int i = 1 * lineCount; i &lt;= (lineCount - 1) * lineCount; i += lineCount) {\n        if (i == (lineCount - 1) * lineCount) {//如果是左下角的一个\n            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - lineCount];\n            continue;\n        }\n        fixSquares[i].next = isClockwise ? fixSquares[i + lineCount] : fixSquares[i - lineCount];\n    }\n    //连接右边\n    for (int i = 2 * lineCount - 1; i &lt;= lineCount * lineCount - 1; i += lineCount) {\n        if (i == lineCount * lineCount - 1) {//如果是右下角的一个\n            fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i - 1];\n            continue;\n        }\n        fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i + lineCount];\n    }\n}\n</code></pre><p>固定方块的位置，分别使用fixFixSquarePosition和fixRollSquarePosition两个方法来固定FixSquare和RollSquare：</p>\n<pre><code>private void fixFixSquarePosition(FixSquare[] fixSquares, int cx, int cy, float dividerWidth, float halfSquareWidth) {\n    //确定第一个rect的位置\n    float squareWidth = halfSquareWidth * 2;\n    int lineCount = (int) Math.sqrt(fixSquares.length);\n    float firstRectLeft = 0;\n    float firstRectTop = 0;\n    if (lineCount % 2 == 0) {//偶数\n        int squareCountInAline = lineCount / 2;\n        int diviCountInAline = squareCountInAline - 1;\n        float firstRectLeftTopFromCenter = squareCountInAline * squareWidth\n                + diviCountInAline * dividerWidth\n                + dividerWidth / 2;\n        firstRectLeft = cx - firstRectLeftTopFromCenter;\n        firstRectTop = cy - firstRectLeftTopFromCenter;\n    } else {//奇数\n        int squareCountInAline = lineCount / 2;\n        int diviCountInAline = squareCountInAline;\n        float firstRectLeftTopFromCenter = squareCountInAline * squareWidth\n                + diviCountInAline * dividerWidth\n                + halfSquareWidth;\n        firstRectLeft = cx - firstRectLeftTopFromCenter;\n        firstRectTop = cy - firstRectLeftTopFromCenter;\n    }\n    for (int i = 0; i &lt; lineCount; i++) {//行\n        for (int j = 0; j &lt; lineCount; j++) {//列\n            if (i == 0) {\n                if (j == 0) {\n                    fixSquares[0].rectF.set(firstRectLeft, firstRectTop,\n                            firstRectLeft + squareWidth, firstRectTop + squareWidth);\n                } else {\n                    int currIndex = i * lineCount + j;\n                    fixSquares[currIndex].rectF.set(fixSquares[currIndex - 1].rectF);\n                    fixSquares[currIndex].rectF.offset(dividerWidth + squareWidth, 0);\n                }\n            } else {\n                int currIndex = i * lineCount + j;\n                fixSquares[currIndex].rectF.set(fixSquares[currIndex - lineCount].rectF);\n                fixSquares[currIndex].rectF.offset(0, dividerWidth + squareWidth);\n            }\n        }\n    }\n}\n\nprivate void fixRollSquarePosition(FixSquare[] fixSquares,\n                                   RollSquare rollSquare, int startEmptyPosition) {\n    FixSquare fixSquare = fixSquares[startEmptyPosition];\n    rollSquare.rectF.set(fixSquare.next.rectF);\n}\n</code></pre><p>对于方法fixFixSquarePosition：</p>\n<ul>\n<li>通过参数有控件的中点的x和y坐标，cx和cy，加上行数，方块的宽以及方块间隔;</li>\n<li>通过以上参数很容易就可以通过计算得出第0个方块的left和top值，分别是firstRectLeft和firstRectTop；</li>\n<li>因为行数可能是奇数也可能是偶数，所以分为奇数和偶数两种计算方式；</li>\n<li>然后我把第一行的方块都固定下来之后，剩下的方块只需要往下平移即可固定下来了；</li>\n<li>第一个for循环表示行，第二个表示列，都是简单的数学计数知识，不过多阐述。</li>\n</ul>\n<p>对于方法fixRollSquarePosition：</p>\n<ul>\n<li>因为我们已经从初始化的操作中知道哪一个位置是空的，startEmptyPosition；</li>\n<li>而且已经把外围的方块连成了环（通过next关联），上文的linkTheOuterSquare方法；</li>\n<li>因此可以很容易确定下来旋转的方块所要开始运动的初始位置。</li>\n</ul>\n<p>②两种运动，平移 和 90度旋转</p>\n<p>这里主要讲解一下思路，使用属性动画创建两个动画，一个是平移动画，一个是旋转动画，如下图，然后使用AnimatorSet将两个连接起来，同时运行。</p>\n<p><img src=\"/2017/06/04/roll_loading/notice4.png\" alt=\"demo3\">图7（平移动画）</p>\n<p><img src=\"/2017/06/04/roll_loading/notice5.png\" alt=\"demo3\">图8（旋转动画）</p>\n<ul>\n<li>由于篇幅有限，加之方法比较长，这里不贴出，感兴趣的朋友可以去原码查看：</li>\n<li>createTranslateValueAnimator方法 和 createRollValueAnimator方法；</li>\n<li>其中值得关注的点是：需要考虑顺逆时针，以及实时更新旋转方块的旋转中心，因为平移过程中旋转中心也会跟着改变的，因此需要改变RollSquare的cx和cy，具体的逻辑就在setRollSquareRotateCenter方法中，调用的时机当然就是在动画运动的过程中啦（见onAnimationUpdate）。</li>\n</ul>\n<p>③循环起来把</p>\n<ul>\n<li>通过调用startRoll方法，会创建一次动画，当动画结束的时候（onAnimationEnd），重新调用startRoll方法，以达到循环的目的。这里相信大家都明白，就跟handler循环发送消息一样。</li>\n<li>这里有一点需要注意的就是如果动画速度调的很快，那么会导致ValueAnimator动画对象频繁重复的创建，可能会有内存抖动的风险；因此建议使用者不要将速度调的太块，不过这个控件的后期的迭代我可能将这个动画对象换成始终只有一个ValueAnimator的情况。</li>\n</ul>\n<p>④停止条件</p>\n<ul>\n<li>在动画结束准备重新调用startRoll方法之前做一个变量判断，来控制是否需要循环调用，如下：</li>\n</ul>\n<pre><code>if (mAllowRoll) {\n    startRoll();\n}\n</code></pre><ul>\n<li>当我们调用stopRoll方法的时候，mAllowRoll会变为false，调用startRoll的时候，mAllowRoll会变为true；</li>\n</ul>\n<p>⑤最后，画出来</p>\n<pre><code>@Override\nprotected void onDraw(Canvas canvas) {\n    for (int i = 0; i &lt; mFixSquares.length; i++) {\n        if (mFixSquares[i].isShow) {\n            canvas.drawRoundRect(mFixSquares[i].rectF, mFixRoundCornor, mFixRoundCornor, mPaint);\n        }\n    }\n    if (mRollSquare.isShow) {\n        canvas.rotate(mIsClockwise ? mRotateDegree : -mRotateDegree, mRollSquare.cx, mRollSquare.cy);\n        canvas.drawRoundRect(mRollSquare.rectF, mRollRoundCornor, mRollRoundCornor, mPaint);\n    }\n}\n</code></pre><p>上文也有提到，最终的绘制分为两步：</p>\n<ol>\n<li>绘制固定的方块</li>\n<li>绘制滚动的方块；</li>\n</ol>\n<p>如果读者还有不明朗的地方，欢迎查看源码，并且给我提bug，一起为这个社区做出自己的微薄贡献。</p>\n","categories":["programming"],"tags":["android","custom_view","effect","snacks"]},{"title":"我觉得我的博文标签是这样分类的","url":"http://halohoop.com/1970/01/01/tags-notes/","content":"<h4 id=\"露水-dewdrops\"><a href=\"#露水-dewdrops\" class=\"headerlink\" title=\"[露水]dewdrops\"></a>[露水]dewdrops</h4><ul>\n<li>琐事，生活体会，心灵鸡汤，更小的技巧等等…</li>\n</ul>\n<h4 id=\"饼干-cookies\"><a href=\"#饼干-cookies\" class=\"headerlink\" title=\"[饼干]cookies\"></a>[饼干]cookies</h4><ul>\n<li>小技巧，小知识点，等等…</li>\n</ul>\n<h4 id=\"点心-snacks\"><a href=\"#点心-snacks\" class=\"headerlink\" title=\"[点心]snacks\"></a>[点心]snacks</h4><ul>\n<li>再大一点的技巧，再大一点的知识点，等等…</li>\n</ul>\n<h4 id=\"大餐-meals\"><a href=\"#大餐-meals\" class=\"headerlink\" title=\"[大餐]meals\"></a>[大餐]meals</h4><ul>\n<li>需要花一些时间的东西，自定义控件，等等…</li>\n</ul>\n<h4 id=\"盛宴-feast\"><a href=\"#盛宴-feast\" class=\"headerlink\" title=\"[盛宴]feast\"></a>[盛宴]feast</h4><ul>\n<li>比较经典的东西，比如某个重要知识点的核心原码分析，等等…</li>\n</ul>\n<h4 id=\"仙丹-elixir\"><a href=\"#仙丹-elixir\" class=\"headerlink\" title=\"[仙丹]elixir\"></a>[仙丹]elixir</h4><ul>\n<li>鸿篇巨制，比如整个项目的分析，等等…</li>\n</ul>\n","categories":["notes"],"tags":["notes"]},{"title":"Hello World","url":"http://halohoop.com/1970/01/01/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","categories":["Hexo教程"],"tags":["tuts","hexo"]},{"title":"about","url":"http://halohoop.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://halohoop.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://halohoop.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://halohoop.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://halohoop.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://halohoop.com/category/index.html","content":"","categories":[],"tags":[]}]