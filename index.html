<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>卖牙膏的芖口钉</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="卖牙膏的芖口钉">
<meta property="og:url" content="http://halohoop.com/index.html">
<meta property="og:site_name" content="卖牙膏的芖口钉">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="卖牙膏的芖口钉">
  
    <link rel="alternate" href="/atom.xml" title="卖牙膏的芖口钉" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">卖牙膏的芖口钉</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">霸气侧漏</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://halohoop.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-cookies-android-touchdelegate" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/cookies-android-touchdelegate/" class="article-date">
  <time datetime="2017-06-05T19:44:09.000Z" itemprop="datePublished">2017-06-06 03:44:09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/cookies-android-touchdelegate/">[饼干]安卓小秘密-不扩大view宽高增加其可触控范围</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="开门撞山："><a href="#开门撞山：" class="headerlink" title="开门撞山："></a>开门撞山：</h2><p>今天我要记录的是<strong>TouchDelegate</strong>，有很多人应该都不知道还有这个东西，知道的孩子都没你们事了，都散了散了吧，不知道的请往下看。其实也不算什么秘密，只要你仔细的走过神迹一样的事件分发的源码，很容易发现的。</p>
<h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><p>如下图，有这样一个场景，View a 需要有这么大，比如可以是一个按钮，UI要求显示View a的黑框部分，但是为了更好的用户体验，我们一般会增大其触控范围，比如点击绿框中都能够触发a的事件，咋做？（说好的不卖关子的呢？）</p>
<p><img src="/2017/06/06/cookies-android-touchdelegate/demo0.png" alt="demo0"></p>
<h2 id="Don’t-do"><a href="#Don’t-do" class="headerlink" title="Don’t do:"></a>Don’t do:</h2><ul>
<li>增加a的Padding?<ul>
<li>后期如果修改bgColor，那么不好了，绿色框内全变色。</li>
</ul>
</li>
<li>套多一层透明的FrameLayout？<ul>
<li>增加布局复杂度，我TM一脚飞死你。 </li>
</ul>
</li>
<li>自定义view限制绘制区域？<ul>
<li>写完了？你很棒！但是你可以收拾包袱走人了。 </li>
</ul>
</li>
</ul>
<h2 id="What-should-do-How-to-use-TouchDelegate-："><a href="#What-should-do-How-to-use-TouchDelegate-：" class="headerlink" title="What should do (How to use TouchDelegate)："></a>What should do (How to use TouchDelegate)：</h2><p>要学会站在巨人的肩膀，要知道，<strong>“你遇到的，巨人也会遇到”</strong>，巨人给我们留下了<strong>TouchDelegate</strong></p>
<h3 id="直接上菜："><a href="#直接上菜：" class="headerlink" title="直接上菜："></a>直接上菜：</h3><p>注意方法ViewGroup.setTouchDelegate(Rect,View)</p>
<p>以下代码出自我一个自定义View—<a href="https://github.com/halohoop/UsoppBubble/blob/master/lib/src/main/java/com/halohoop/usoppbubble/widget/UsoppBubble.java" target="_blank" rel="external">UsoppBubble.java</a></p>
<pre><code>@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    if (changed) {
        float largedSize = (bottom - top) * mTouchAreaLargerRatio;//乘以放大倍数
        int deltaY = (int) (largedSize - (bottom - top));
        int deltaX = largedSize &gt; (right - left) ? (int) (largedSize - (right - left)) : 0;
        ViewGroup vg = (ViewGroup) getParent();
        Rect rect = new Rect(left - deltaX, top - deltaY, right + deltaX, bottom + deltaY);
        //构建出来的Rect对象就相当于绿色框框，而this就是这个view的实例。
        vg.setTouchDelegate(new TouchDelegate(rect, this));
    }
}
</code></pre><p>相信上述代码是极度容易的，ViewGroup.setTouchDelegate(Rect,View)接受两个参数：</p>
<ul>
<li>可触控区域。</li>
<li>谁(哪个子view)需要用这个可触控区域。</li>
</ul>
<h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul>
<li>QQ消息气泡可触控区域</li>
</ul>
<p><img src="/2017/06/06/cookies-android-touchdelegate/demo1.png" alt="demo1"></p>
<ul>
<li>当然我也模仿qq做了一个<a href="https://github.com/halohoop/UsoppBubble" target="_blank" rel="external">自己的消息气泡版本</a></li>
</ul>
<p><img src="/2017/06/06/cookies-android-touchdelegate/demo2.gif" alt="demo2"></p>
<ul>
<li>小米贴边悬浮球点击唤醒</li>
</ul>
<p><img src="/2017/06/06/cookies-android-touchdelegate/demo3.png" alt="demo3"></p>
<ul>
<li>锤子的闪念胶囊贴边点击唤醒</li>
</ul>
<p><img src="/2017/06/06/cookies-android-touchdelegate/demo4.png" alt="demo4"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>View.setTouchDelegate(Rect,View)，这句还不够吗？还要我怎样？</li>
<li>你遇到的，巨人也会遇到，如果换位思考一下，你就是“巨人”，那么子View获取到的触摸事件是从ViewGroup分发下来的，那么如果在分发之前加一些条件判断，比如区域什么的，那么TouchDelegate这玩意儿是不是就出来了呢？</li>
<li>Stay hungry stay foolish!</li>
</ul>
<p><em>仅作知识点记录，如有疏漏，全(欢)都(迎)怪(指)你(正)。</em></p>
<hr>
<p>确保这文章被看完了，我在上面留了一个无伤大雅的bug，不知道有人发现没有，那就是：</p>
<p><em>setTouchDelegate其实是View的方法。而ViewGroup : View，无伤大雅。</em></p>
<p><strong>顺便说一下，科学上网之后浏览本站文章可以评论。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://halohoop.com/2017/06/06/cookies-android-touchdelegate/" data-id="cj3lmkz2d0000bgtlvyt8qb0c" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cookies/">cookies</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/">view</a></li></ul>

    </footer>
	<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "cbb093ce3d1143eba2f2196086c1116f",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
  </div>
  
</article>


  
    <article id="post-cookies-kotlin-trick-001" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/05/cookies-kotlin-trick-001/" class="article-date">
  <time datetime="2017-06-05T08:15:36.242Z" itemprop="datePublished">2017-06-05 16:15:36</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/05/cookies-kotlin-trick-001/">[饼干]Kotlin Trick 001-省略一些重复的工作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好的文章有时候不在于鸿篇巨制，而在于一目了然，有时候这种快餐小技巧更能帮助人，没有铺垫没有客套，直戳掌握知识的要害。所以从这篇开始会不间断的记录一些小技巧，文章已[饼干]开头的都是一篇短文。</p>
<p>一些重复的工作，比如说我们在性能调优的时候经常用到的Trace，以下是一个实例：</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java:"></a>Java:</h2><pre><code>Trace.beginSection(sectionName);
doSomeCalculation();
Trace.endSection();
</code></pre><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>如果在每个地方都加入<strong>Trace.beginSection(sectionName)和Trace.endSection()</strong>会疯掉的，搞不好还忘记加Trace.endSection()。</p>
<h2 id="When-it-comes-to-Kotlin："><a href="#When-it-comes-to-Kotlin：" class="headerlink" title="When it comes to Kotlin："></a>When it comes to Kotlin：</h2><pre><code>inline fun trace(sectionName: String, body: () -&gt; Unit) {
    Trace.beginSection(sectionName)
    try {
        body()
    } finally {
        Trace.endSection()
    }
}
//and use it
trace(&quot;foo&quot;) {
    doSomeCalculation()
}
</code></pre><p>这样我们就可以把Trace.beginSection(sectionName)和Trace.endSection()省略了。<br>甚至你还可以有返回值：</p>
<pre><code>inline fun &lt;T&gt; trace(sectionName: String, body: () -&gt; T): T {
    Trace.beginSection(sectionName)
    try {
        return body()
    } finally {
        Trace.endSection()
    }
}

//and use it
val result = trace(&quot;foo&quot;) {
    doSomeCalculation()
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>实际上这种方式是方法拓展，lambda带给我们的额便利，同样的技巧，相信你能应用到Trace以外更多的地方，相信你能接触到更好的用法。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://halohoop.com/2017/06/05/cookies-kotlin-trick-001/" data-id="cj3lmkz3l000ibgtlzujs7pf0" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cookies/">cookies</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kotlin/">kotlin</a></li></ul>

    </footer>
	<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "cbb093ce3d1143eba2f2196086c1116f",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
  </div>
  
</article>


  
    <article id="post-roll_loading" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/04/roll_loading/" class="article-date">
  <time datetime="2017-06-03T16:44:09.000Z" itemprop="datePublished">2017-06-04 00:44:09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/roll_loading/">[小吃]小清新加载等待控件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></p>
<p>控件源码：<a href="https://github.com/halohoop/RollSquareView" target="_blank" rel="external">https://github.com/halohoop/RollSquareView</a></p>
<p>正文</p>
<p>背景<br>从锤子手机上看到的效果，锤子系统更新界面的入口按钮就是这个加载动画。</p>
<p>效果图</p>
<p><img src="/2017/06/04/roll_loading/roll_demo3.gif" alt="demo1"> 图1(效果图1)</p>
<p><img src="/2017/06/04/roll_loading/roll_demo2.gif" alt="demo2"> 图2(效果图2)</p>
<p>使用方式</p>
<p><img src="/2017/06/04/roll_loading/roll_demo.png" alt="demo3"> 图3(使用说明图)</p>
<ul>
<li>half_rect_width:半个方块的宽度，单位dp</li>
<li>rect_divier_width:方块之间间隔宽度，单位dp</li>
<li>start_empty_position:初始空出的位置</li>
<li>is_clockwise:是否顺时针旋转</li>
<li>line_count:一行的数量，最少为3</li>
<li>fix_round_cornor:固定的方框的圆角半径</li>
<li>roll_round_cornor:旋转的方框的圆角半径，如果这两个圆角半径设置成不一样的值就会得到上面图1的效果，设置成一样就是图2.</li>
<li>roll_when_show_stop_when_hide:是否自动开始自定旋转，如果设置为false，则需要手动调用startRoll()方法(下文会提到)才会开始运动，设置为true则设置View.Visibility就会自动开始旋转。</li>
<li>square_color:方块的颜色。使用十六进制代码的形式（如：#333、#8e8e8e）</li>
</ul>
<p>讲解实现方法之前，首先要说明一下方格的排列方式是从左到右，从上到下，也就是如果line_count设置为3，那么方格的序号如下图：</p>
<p><img src="/2017/06/04/roll_loading/notice1.png" alt="demo3"> 图4(序号排列说明)</p>
<p>实现思路：<br>自定义控件最主要的就是如何去准备要展示给用户看的东西，东西有了之后，我们在onDraw方法里面按部就班的画出来就可以了。接下来就带大家来走一走我准备的整个过程。其实整个过程就像做菜，准备材料（准备数据），加调味料（处理初始数据），翻炒（编写逻辑），这一切都是在锅中完成的，这个锅就是我们的onDraw方法，我们把所有的一些都准备好，然后扔进锅（onDraw）里面。</p>
<p>最终的绘制分为两步：</p>
<ul>
<li>绘制固定的方块</li>
<li>绘制滚动的方块</li>
</ul>
<p>当运动的时候将固定的方框中的两个方块隐藏，然后让滚动的方块继承其中一个的位置，然后通过属性动画改变其位置的值以及旋转角度的值，最终调用invalidate()重绘让其动起来。</p>
<p><img src="/2017/06/04/roll_loading/notice3.png" alt="demo3"> 图5(绘制原理图示)</p>
<p>①（控件精髓就在此处）根据配置准备绘制的数据</p>
<p>处理自定义属性：</p>
<pre><code>private void initAttrs(Context context, AttributeSet attrs) {
    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.RollSquareView);
    //行列数
    mLineCount = typedArray.getInteger(R.styleable.RollSquareView_line_count, 3);
    //旋转的方块圆角
    mRollRoundCornor = typedArray.getFloat(R.styleable.RollSquareView_roll_round_cornor, 10);
    ...
    其他属性省略，请大家看源码

    //开始的空格位置
    mStartEmptyPosition = typedArray.getInteger(R.styleable.RollSquareView_start_empty_position, 0);
    if (isInsideTheRect(mStartEmptyPosition, mLineCount)) {
        mStartEmptyPosition = 0;
    }
    //当动态滚动的时候实时更新的空格位置
    mCurrEmptyPosition = mStartEmptyPosition;
    typedArray.recycle();
}
</code></pre><p>当选择空格位置不是外围的方块序号的时候，自动选择0位置，判断是否外围一圈的算法如下，纯数学知识：</p>
<p><img src="/2017/06/04/roll_loading/notice2.png" alt="demo3"> 图6(绿色框出来的就是非外围的方块)</p>
<pre><code>private boolean isInsideTheRect(int pos, int lineCount) {
    if (pos &lt; lineCount) {//是否第一行
        return false;
    } else if (pos &gt; (lineCount * lineCount - 1 - lineCount)) {//是否最后一行
        return false;
    } else if ((pos + 1) % lineCount == 0) {//是否右边
        return false;
    } else if (pos % lineCount == 0) {//是否左边
        return false;
    }
    //四边都不在，那就是在内部了
    return true;
}
</code></pre><p>初始化方块的方法：</p>
<pre><code>private void initSquares(int startEmptyPosition) {
    //创建mLineCount * mLineCount个方块
    mFixSquares = new FixSquare[mLineCount * mLineCount];
    for (int i = 0; i &lt; mFixSquares.length; i++) {
        mFixSquares[i] = new FixSquare();
        mFixSquares[i].index = i;
        mFixSquares[i].isShow = startEmptyPosition == i ? false : true;
        mFixSquares[i].rectF = new RectF();
    }
    //外圈链接起来
    linkTheOuterSquare(mFixSquares, mIsClockwise);//下文讲解
    //创建1个滚动方块
    mRollSquare = new RollSquare();
    mRollSquare.rectF = new RectF();
    mRollSquare.isShow = false;
}
</code></pre><p>两种方块都使用内部类定义，代码如下：</p>
<pre><code>private class FixSquare {
    RectF rectF;//需要绘制的方块
    int index;//所在的序号
    boolean isShow;//是否需要绘制
    FixSquare next;//指向下一个需要滚动的位置，顺时针和逆时针相反
}

private class RollSquare {
    RectF rectF;//需要绘制的方块
    int index;//所在的序号
    boolean isShow;//是否需要绘制
    /**
     * 旋转中心坐标
     */
    float cx;//滚动的时候的旋转中心x
    float cy;//滚动的时候的旋转中心y
}
</code></pre><p>我们可以看到固定的方块FixSquare中有一个next变量：</p>
<pre><code>FixSquare next;//指向下一个需要滚动的位置，顺时针和逆时针相反
</code></pre><p>因为我们需要将外围的一圈方块都链接起来，但是现在有一个问题就是外围的方块序号并不是按照0、1、2…排列的，因此我定义了一个next变量用于指定其下一个，这样一个接一个的就把外围连成一圈了。算法如下，可能第一次看这个方法的小伙伴需要看一小会儿，因为需要适配行数3个以上的需求，因此都是动态变化的，因此都是一些数学公式，这里篇幅有限不一一讲解，大家可以顺着注释看看规律就很容易理解了，这个方法的主要目的就是为了让每个FixSquare的“FixSquare next”都赋上值，最终将外围都连成一圈，不要忘记考虑顺逆时针isClockwise这个变量哦：</p>
<pre><code>private void linkTheOuterSquare(FixSquare[] fixSquares, boolean isClockwise) {
    int lineCount = (int) Math.sqrt(mFixSquares.length);
    //连接第一行
    for (int i = 0; i &lt; lineCount; i++) {
        if (i % lineCount == 0) {//位于最左边
            fixSquares[i].next = isClockwise ? fixSquares[i + lineCount] : fixSquares[i + 1];
        } else if ((i + 1) % lineCount == 0) {//位于最右边
            fixSquares[i].next = isClockwise ? fixSquares[i - 1] : fixSquares[i + lineCount];
        } else {//中间
            fixSquares[i].next = isClockwise ? fixSquares[i - 1] : fixSquares[i + 1];
        }
    }
    //连接最后一行
    for (int i = (lineCount - 1) * lineCount; i &lt; lineCount * lineCount; i++) {
        if (i % lineCount == 0) {//位于最左边
            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - lineCount];
        } else if ((i + 1) % lineCount == 0) {//位于最右边
            fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i - 1];
        } else {//中间
            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - 1];
        }
    }
    //连接左边
    for (int i = 1 * lineCount; i &lt;= (lineCount - 1) * lineCount; i += lineCount) {
        if (i == (lineCount - 1) * lineCount) {//如果是左下角的一个
            fixSquares[i].next = isClockwise ? fixSquares[i + 1] : fixSquares[i - lineCount];
            continue;
        }
        fixSquares[i].next = isClockwise ? fixSquares[i + lineCount] : fixSquares[i - lineCount];
    }
    //连接右边
    for (int i = 2 * lineCount - 1; i &lt;= lineCount * lineCount - 1; i += lineCount) {
        if (i == lineCount * lineCount - 1) {//如果是右下角的一个
            fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i - 1];
            continue;
        }
        fixSquares[i].next = isClockwise ? fixSquares[i - lineCount] : fixSquares[i + lineCount];
    }
}
</code></pre><p>固定方块的位置，分别使用fixFixSquarePosition和fixRollSquarePosition两个方法来固定FixSquare和RollSquare：</p>
<pre><code>private void fixFixSquarePosition(FixSquare[] fixSquares, int cx, int cy, float dividerWidth, float halfSquareWidth) {
    //确定第一个rect的位置
    float squareWidth = halfSquareWidth * 2;
    int lineCount = (int) Math.sqrt(fixSquares.length);
    float firstRectLeft = 0;
    float firstRectTop = 0;
    if (lineCount % 2 == 0) {//偶数
        int squareCountInAline = lineCount / 2;
        int diviCountInAline = squareCountInAline - 1;
        float firstRectLeftTopFromCenter = squareCountInAline * squareWidth
                + diviCountInAline * dividerWidth
                + dividerWidth / 2;
        firstRectLeft = cx - firstRectLeftTopFromCenter;
        firstRectTop = cy - firstRectLeftTopFromCenter;
    } else {//奇数
        int squareCountInAline = lineCount / 2;
        int diviCountInAline = squareCountInAline;
        float firstRectLeftTopFromCenter = squareCountInAline * squareWidth
                + diviCountInAline * dividerWidth
                + halfSquareWidth;
        firstRectLeft = cx - firstRectLeftTopFromCenter;
        firstRectTop = cy - firstRectLeftTopFromCenter;
    }
    for (int i = 0; i &lt; lineCount; i++) {//行
        for (int j = 0; j &lt; lineCount; j++) {//列
            if (i == 0) {
                if (j == 0) {
                    fixSquares[0].rectF.set(firstRectLeft, firstRectTop,
                            firstRectLeft + squareWidth, firstRectTop + squareWidth);
                } else {
                    int currIndex = i * lineCount + j;
                    fixSquares[currIndex].rectF.set(fixSquares[currIndex - 1].rectF);
                    fixSquares[currIndex].rectF.offset(dividerWidth + squareWidth, 0);
                }
            } else {
                int currIndex = i * lineCount + j;
                fixSquares[currIndex].rectF.set(fixSquares[currIndex - lineCount].rectF);
                fixSquares[currIndex].rectF.offset(0, dividerWidth + squareWidth);
            }
        }
    }
}

private void fixRollSquarePosition(FixSquare[] fixSquares,
                                   RollSquare rollSquare, int startEmptyPosition) {
    FixSquare fixSquare = fixSquares[startEmptyPosition];
    rollSquare.rectF.set(fixSquare.next.rectF);
}
</code></pre><p>对于方法fixFixSquarePosition：</p>
<ul>
<li>通过参数有控件的中点的x和y坐标，cx和cy，加上行数，方块的宽以及方块间隔;</li>
<li>通过以上参数很容易就可以通过计算得出第0个方块的left和top值，分别是firstRectLeft和firstRectTop；</li>
<li>因为行数可能是奇数也可能是偶数，所以分为奇数和偶数两种计算方式；</li>
<li>然后我把第一行的方块都固定下来之后，剩下的方块只需要往下平移即可固定下来了；</li>
<li>第一个for循环表示行，第二个表示列，都是简单的数学计数知识，不过多阐述。</li>
</ul>
<p>对于方法fixRollSquarePosition：</p>
<ul>
<li>因为我们已经从初始化的操作中知道哪一个位置是空的，startEmptyPosition；</li>
<li>而且已经把外围的方块连成了环（通过next关联），上文的linkTheOuterSquare方法；</li>
<li>因此可以很容易确定下来旋转的方块所要开始运动的初始位置。</li>
</ul>
<p>②两种运动，平移 和 90度旋转</p>
<p>这里主要讲解一下思路，使用属性动画创建两个动画，一个是平移动画，一个是旋转动画，如下图，然后使用AnimatorSet将两个连接起来，同时运行。</p>
<p><img src="/2017/06/04/roll_loading/notice4.png" alt="demo3">图7（平移动画）</p>
<p><img src="/2017/06/04/roll_loading/notice5.png" alt="demo3">图8（旋转动画）</p>
<ul>
<li>由于篇幅有限，加之方法比较长，这里不贴出，感兴趣的朋友可以去原码查看：</li>
<li>createTranslateValueAnimator方法 和 createRollValueAnimator方法；</li>
<li>其中值得关注的点是：需要考虑顺逆时针，以及实时更新旋转方块的旋转中心，因为平移过程中旋转中心也会跟着改变的，因此需要改变RollSquare的cx和cy，具体的逻辑就在setRollSquareRotateCenter方法中，调用的时机当然就是在动画运动的过程中啦（见onAnimationUpdate）。</li>
</ul>
<p>③循环起来把</p>
<ul>
<li>通过调用startRoll方法，会创建一次动画，当动画结束的时候（onAnimationEnd），重新调用startRoll方法，以达到循环的目的。这里相信大家都明白，就跟handler循环发送消息一样。</li>
<li>这里有一点需要注意的就是如果动画速度调的很快，那么会导致ValueAnimator动画对象频繁重复的创建，可能会有内存抖动的风险；因此建议使用者不要将速度调的太块，不过这个控件的后期的迭代我可能将这个动画对象换成始终只有一个ValueAnimator的情况。</li>
</ul>
<p>④停止条件</p>
<ul>
<li>在动画结束准备重新调用startRoll方法之前做一个变量判断，来控制是否需要循环调用，如下：</li>
</ul>
<pre><code>if (mAllowRoll) {
    startRoll();
}
</code></pre><ul>
<li>当我们调用stopRoll方法的时候，mAllowRoll会变为false，调用startRoll的时候，mAllowRoll会变为true；</li>
</ul>
<p>⑤最后，画出来</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    for (int i = 0; i &lt; mFixSquares.length; i++) {
        if (mFixSquares[i].isShow) {
            canvas.drawRoundRect(mFixSquares[i].rectF, mFixRoundCornor, mFixRoundCornor, mPaint);
        }
    }
    if (mRollSquare.isShow) {
        canvas.rotate(mIsClockwise ? mRotateDegree : -mRotateDegree, mRollSquare.cx, mRollSquare.cy);
        canvas.drawRoundRect(mRollSquare.rectF, mRollRoundCornor, mRollRoundCornor, mPaint);
    }
}
</code></pre><p>上文也有提到，最终的绘制分为两步：</p>
<ol>
<li>绘制固定的方块</li>
<li>绘制滚动的方块；</li>
</ol>
<p>如果读者还有不明朗的地方，欢迎查看源码，并且给我提bug，一起为这个社区做出自己的微薄贡献。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://halohoop.com/2017/06/04/roll_loading/" data-id="cj3lmkz3g000gbgtlnqm6dtb4" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/custom-view/">custom_view</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/effect/">effect</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/snacks/">snacks</a></li></ul>

    </footer>
	<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "cbb093ce3d1143eba2f2196086c1116f",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/1970/01/01/hello-world/" class="article-date">
  <time datetime="1969-12-31T16:00:01.000Z" itemprop="datePublished">1970-01-01 00:00:01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hexo教程/">Hexo教程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/1970/01/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://halohoop.com/1970/01/01/hello-world/" data-id="cj3lmkz2j0001bgtllqgm1xg5" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tuts/">tuts</a></li></ul>

    </footer>
	<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "cbb093ce3d1143eba2f2196086c1116f",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categorieën</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo教程/">Hexo教程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">programming</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cookies/">cookies</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/custom-view/">custom_view</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/effect/">effect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/snacks/">snacks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tuts/">tuts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/view/">view</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/cookies/" style="font-size: 15px;">cookies</a> <a href="/tags/custom-view/" style="font-size: 10px;">custom_view</a> <a href="/tags/effect/" style="font-size: 10px;">effect</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/kotlin/" style="font-size: 10px;">kotlin</a> <a href="/tags/snacks/" style="font-size: 10px;">snacks</a> <a href="/tags/tuts/" style="font-size: 10px;">tuts</a> <a href="/tags/view/" style="font-size: 10px;">view</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1970/01/">January 1970</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/06/cookies-android-touchdelegate/">[饼干]安卓小秘密-不扩大view宽高增加其可触控范围</a>
          </li>
        
          <li>
            <a href="/2017/06/05/cookies-kotlin-trick-001/">[饼干]Kotlin Trick 001-省略一些重复的工作</a>
          </li>
        
          <li>
            <a href="/2017/06/04/roll_loading/">[小吃]小清新加载等待控件</a>
          </li>
        
          <li>
            <a href="/1970/01/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Halohoop<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "cbb093ce3d1143eba2f2196086c1116f",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>