<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="我有病，你有药嘛？"><meta name="keywords" content=""><meta name="author" content="Halohoop"><meta name="copyright" content="Halohoop"><title>我有病，你有药嘛？ | 卖牙膏的芖口钉</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8d386d3f58d003ed2f4b4d02e584d2ae";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/halohoop/cdn/github/avatar.jpg"></div><div class="author-info__name text-center">Halohoop</div><div class="author-info__description text-center">我有病，你有药嘛？</div><div class="follow-button"><a href="https://github.com/halohoop">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">32</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">37</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://www.kfc.com">KFC</a><a class="author-info-links__name text-center" href="https://www.mcdonalds.com.cn">Mcdonalds</a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">卖牙膏的芖口钉</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="site-info"><div id="site-title">卖牙膏的芖口钉</div><div id="site-sub-title">我有病，你有药嘛？</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/08/tricks_of_mac_001/">tricks_of_mac-001-MacOS对话框脱离鼠标操作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-08 04:00:09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/cookies-tricks-of-mac/">cookies tricks_of_mac</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/mac/">mac</a></span><div class="content"><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>不知道你有没有发现当你在MacOS上删除一个文件或者一条短信的，你会得到一个类似下图这样的对话框，但是可能有时候默认的选中的按钮不是你想要的，这个时候按方向键是没有反应的，需要按<code>【TAB】</code>键。</p>
<p><img src="/2020/03/08/tricks_of_mac_001/1.png" alt="1"></p>
<p>于是你按了<code>【TAB】</code>键，发现<code>【删除】</code>按钮被蓝色框框选中了，这个时候你按<code>【回车】</code>，发现确是<code>【取消】</code>按钮被触发了。</p>
<p><img src="/2020/03/08/tricks_of_mac_001/2.png" alt="1"></p>
<h2 id="原因解释"><a href="#原因解释" class="headerlink" title="原因解释"></a>原因解释</h2><p>MacOS的对话框在按钮触发的设计上分的很细，分为：</p>
<ol>
<li>蓝色背景按钮的触发；</li>
<li>蓝色框框按钮的触发；</li>
</ol>
<p><strong><u>蓝色背景的按钮是通过<code>【回车】</code>来触发的，而蓝色框框的按钮则是通过<code>【空格Space键】</code>来触发的</u></strong></p>
<p>所以要完成以上删除场景的操作，正确的操作步骤应该是：<code>【TAB】</code>-&gt;<code>【SPACE】</code>。</p>
<p>Bye~</p>
<p>Hope it works~</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/02/about_2019_ncov/">整理：关于武汉肺炎可以普及的'知识'</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-02 17:15:00</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/life/">life</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/virus/">virus</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/细菌/">细菌</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/病毒/">病毒</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/李文亮/">李文亮</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/陈秋实/">陈秋实</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/武汉病毒实验室/">武汉病毒实验室</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/方斌/">方斌</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/次氯酸/">次氯酸</a></span><div class="content"><p><img src="/2020/02/02/about_2019_ncov/c908115d0a434800b379ac686beec76e.jpg" alt="武汉加油"></p>
<p><strong>戴口罩，多洗手，别摸口鼻眼，不管是天灾还是人祸，天佑我中华。 </strong></p>
<p><em>声明：以下文章内容大部分转载于网络。</em></p>
<ol>
<li><p>细菌和病毒是同一个东西吗？什么是冠状病毒？</p>
<ol>
<li><p>这个去看李永乐老师的关于冠状病毒的那期就可以了。参考链接：<a href="https://www.ixigua.com/i6786939642429047307/" target="_blank" rel="external">“冠状病毒”是什么？武汉新型肺炎病毒是如何使人生病的？</a>(视频26分钟)。</p>
<p><img src="/2020/02/02/about_2019_ncov/Xnip2020-02-02_19-09-37.png" alt="冠状病毒"></p>
</li>
</ol>
</li>
<li><p>为什么是75%浓度的酒精才可以杀菌？</p>
</li>
<li><p>酒精可以杀灭病毒吗？杀菌消毒和细菌、病毒的外膜(套膜)有什么关系？次氯酸水VS酒精哪个消毒更好？</p>
<p>2和3也都可以通过搜索获得。参考视频：<a href="https://www.youtube.com/watch?v=q_ISwd_rh3M" target="_blank" rel="external">【約翰老師小教室】次氯酸vs酒精vs漂白水</a>(视频2分钟)</p>
<p><img src="/2020/02/02/about_2019_ncov/Xnip2020-02-02_18-40-44.png" alt="有外膜"></p>
<p><img src="/2020/02/02/about_2019_ncov/Xnip2020-02-02_18-34-54.png" alt="无外膜"></p>
<ol>
<li><p>有一个一块钱成本电解制作次氯酸水的视频可以去了解下，这个在应对当前各种酒精脱销的情况下还是挺有用的。参考链接：<a href="https://www.youtube.com/watch?v=hXS6bHcGkw0" target="_blank" rel="external">武漢肺炎 唯有自救才能救人</a>，视频我已经扒下来了，”看不到”可以找我要资源。</p>
<p><img src="/2020/02/02/about_2019_ncov/Xnip2020-02-02_18-35-29.png" alt="次氯酸"></p>
</li>
</ol>
</li>
<li><p>基本传染数R0是什么意思？</p>
<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/104128326?utm_source=wechat_timeline" target="_blank" rel="external">科普 | 基本传染数 R0</a></p>
</li>
<li><p>是真的有哪一篇报道有直接证据证明是因为接触了蝙蝠、野味引起这次瘟疫的嘛？求链接。</p>
<p>在它们身上发现了病毒是否就等于因为接触了而引起？还是为了限制追责，将舆论引至此为止？</p>
</li>
<li><p>“人民日报”是否会不知道双黄连口服液那篇POST发出来之后的结果嘛？</p>
<p><img src="/2020/02/02/about_2019_ncov/WechatIMG776.jpeg" alt="双黄连口服液"></p>
<p>有人去扒了WH病毒实验室所长王某某和双黄连口服液相关制药公司上海绿谷制药有限公司相关的高层的关系，这个思考方向就挺有意思。<a href="https://www.zhihu.com/question/368894346" target="_blank" rel="external">参考链接</a>.</p>
</li>
<li><p>李文亮是谁？经历了什么？做了什么事？</p>
<p>真的可以了解到“打你一巴掌然后再给你糖吃”的精髓是如何被诠释的。</p>
</li>
<li><p>12月底病毒就被检测出来了，1月7才有响应中间是发生了什么？为何响应如此的缓慢和平平。</p>
<ol>
<li>文章请搜索“记录一下首次发现新型冠状病毒的经历”，国内媒体有删帖的可能。</li>
<li>思考：作为纳税人，你能够容忍或原谅国家社会的领导人失职的底线到什么程度？</li>
</ol>
</li>
<li><p>武汉里面到底是怎么样一个状况了？</p>
<p>陈秋实何许人也？口罩哥何许人也？方斌何许人也？……经历了什么？做了什么事？有条件的自行了解。</p>
</li>
</ol>
<p><strong>希望“亲自指挥，亲自部署”的领导人一定要尽早解救我们尤其是被困在严重疫区里面的兄弟姐妹同胞们~</strong></p>
<p><img src="/2020/02/02/about_2019_ncov/WechatIMG775.jpeg" alt="天佑中华"></p>
<p>Just Feel FREEEEEEEEEEE to Contact Me：</p>
<p>Email: <a href="mailto:halohoopwong@gmail.com" target="_blank" rel="external">halohoopwong@gmail.com</a></p>
<p>Wechat: halohoop</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/11/explanation_of_uncoupled/">[饼干]如何向你的不懂编程的领导或者朋友解释什么是解耦</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-11 01:10:50</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/programming/">programming</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/cookies/">cookies</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/coding/">coding</a></span><div class="content"><p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>
<p>什么叫做解耦，其实就是用一个通用的桥梁去沟通有关联的两者，这里有个关键的点，通用的。不太理解？那就请带着不理解继续往下读，请允许我给您说说我的理解。</p>
<p>​我们学习一个新事物的时候一般都会类比自己已经熟知的相似的事物，要把解耦类比到我们生活中也很简单。想象一个场景，你在一个钉钉群里面共享了一个文件，”报销报表填写.xls”，需要大家填写后发回给你，然而群里大家正聊的热火朝天，很快文件的那条消息就被掩盖了，但是如果提供的是一个下载地址，这就解耦了，为什么解耦了，因为他可以很方便的复用在公告栏、个人资料、聊天昵称等任何的地方中。</p>
<p>我们可能都听过一句经典的名言：“计算机界任何的问题都可以通过引入一个第三方来进行解决”，这里的解耦也是一样的，我们引入的第三方是一个字符串的抽象概念，一段URL字符串地址，可以代表一个exe文件，但是反过来，一个exe文件就不能够代表一个段URL字符串地址了。引入了这个第三方的字符串概念之后，由于它不仅具有路由的属性（即可以通过访问找到目标文件），而且具有了一定的独立性（一串字符集合完整代表了一个文件），而且的而且，又带有绝对可传播的特点（即可以“复制粘贴书写口述”到任何想要的地方）。</p>
<p>所以，解耦你理解了吗？</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/03/06/stateofaprogram/">《用程序的状态来衡量一个程序猿的成长大概是这样》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-06 01:23:10</time><div class="content"><p><img src="/2019/03/06/stateofaprogram/1.png" alt="1"><br><img src="/2019/03/06/stateofaprogram/2.png" alt="2"><br><img src="/2019/03/06/stateofaprogram/3.png" alt="3"></p>
<pre><code>————HQ. 
————19.3.6 
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/10/03/atease/">《心安》</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-03 00:10:40</time><div class="content"><p><img src="/2018/10/03/atease/atease.jpg" alt="atease"></p>
<p>很多时候，“人一旦认定一件事情，想法就会变的片面。”就像脑海里一颗疯狂活化的种子，一旦落地发芽，就肆意生长蔓延。</p>
<p>殊不知，其实自己的想法可以有更多的可能性，只是因为一开始就决定了方向，才导致这样那样的结果或想法。</p>
<p>但是，人一生很多事很多时候可能就只会有那么一个方向，因为通常我们都只交那些能够迁就着你的想法的“伙伴”，鲜有人会再帮你追根溯源再为你重新种下另一颗种子。</p>
<p>很多时候每个人都会认为，我掌握了一项技能，那么我就认定超出这个技能能够完成的事情的范畴的事情，就是无法完成的；我阅人无数，那么我就认定了我只需要只言片语的交流就能够轻易定义他或她是个怎么样的人，有没有资格做我的“伙伴”，甚至都懒得多问一句来直接求证自己的定义；</p>
<p>虽然结果看起来片面，但是这就是人们已经充分利用起来的“经验”，并且已经用很多生活中工作中的事例来反复印证过了的，但是也因此，很多时候也导致很多可能性也许还没有开始就已经宣告结束了。</p>
<p>虽然我们可能没有办法阻止每一个大方向发展的结局，但是我们能够以一种开放的心态来让自己宽容对待这些由于经验带来的或好或坏的结果。</p>
<p>就像即将要了结一个制定好的目标，要能够享受成功带来的喜悦，也要能够承受失败带来的失落。我经常制定的宏大的计划，却没有一次能够完美完成，但是我也会总结原因继续前进。</p>
<p>就像要认真对待的一份爱情，要能够享受爱带来的愉悦，也要能够坦然接纳不爱带来的伤感。好比我，虽然没有人爱我，甚至有时候女孩子连对我多说一句话都懒得说（就是所谓的丑拒，人丑没办法），但我也会坦然的接收这样的事实。</p>
<p>也许这就是所谓的心安吧。</p>
<p>在我，让自己想法足够单纯，是一切心安的原因。我始终藏有一份心意，我希望并且也努力的做到让它是单纯的，美好的，不管别人收或不收，我都会将这一份单纯的美好经营下去，因为这个就是我认定的事情，不在乎结果好坏，不计较得失，也始终相信会有“伙伴”们欣赏这一份独一无二的心意。</p>
<p>努力。</p>
<pre><code>————HQ. 
————18.10.3 
</code></pre></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/13/snacks_android_permission_check/">[点心]Android权限判断中的版本兼容</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-13 00:55:02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tricks/">tricks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/snacks/">snacks</a></span><div class="content"><p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>
<p>在Android中，我们会经常遇到一些需要检查权限允许后才可以进行的一些操作，尤其是Android 6.0以及以后版本最为明显，我们知道Android6.0后引入了运行时权限检查，如果没有权限那么某些隐私的功能就无法使用。<br>那么在针对公司的某些服务，制作一款Android SDK的时候，也是一样的，需要使用到权限检查。<br>庆幸的是，Support Library V4包中已帮我们封装好了一个静态权限检查方法，ContextCompat#checkSelfPermission：</p>
<hr>
<pre><code>ContextCompat.checkSelfPermission(@NonNull Context context, @NonNull String permission)
</code></pre><hr>
<p>我当然可以直接调用这个方法，但是，在打包SDK为Jar的时候就不得不带上这个V4包的，这样会增大SDK整体包的大小，不建议使用，当然我们可以打包的时候不加入这个V4包，然后乞求用户在使用我们SDK的时候加入V4包，但是这显然不是一个专业的操作，用户根据自己的业务需求是不一定会引入V4包的，所以凭什么要使用你SDK的用户去买单，引入一个其他功能都不一定使用到的包。另外，引入这个V4包的SDK集成到其他应用中时候还有可能造成V4包冲突的风险，因为其他应用可能也有用到V4包。</p>
<p>作为一个有节操的SDK，必须解决这个问题，又因为V4是Android屏蔽版本区别的一个支持库，因此其中的方法一定是版本兼容的，于是在技术本能的驱使下，我深入这个checkSelfPermission方法一探究竟：</p>
<hr>
<pre><code>public static int checkSelfPermission(@NonNull Context context, @NonNull String permission) {
    if (permission == null) {
        throw new IllegalArgumentException(&quot;permission is null&quot;);
    }
    return context.checkPermission(permission, android.os.Process.myPid(), Process.myUid());
}
</code></pre><hr>
<p>核心方法就是一句，调用Context#checkPermission方法，返回的int类型不同的值代表不同的权限。见下图。</p>
<p><img src="/2018/07/13/snacks_android_permission_check/1.png" alt="demo1"></p>
<p>燃鹅，我觉得这个方法需要太多参数，因为在一个应用，后面两个参数其实都是固定的，pid和uid（具体这两个变量是什么含义可以自行查阅），Google应该没有傻到让我做多余的事情，因此我决定进一步寻找，于是找到了这个方法Context#checkSelfPermission，果然只需要传递一个String权限参数，哈哈，和Google想到一块儿去了。见下图。</p>
<p><img src="/2018/07/13/snacks_android_permission_check/2.png" alt="demo2"></p>
<p>燃鹅的再燃鹅，看看左上角，这个方法特么的是“added in API level 23”，也就是说我在Android 6.0 以下的SDK中特么的无法使用啊，法使用啊，使用啊，用啊，啊。<br>如果有跟上我思路的童鞋，在这里可能就会有小疑问了：为什么既然这个方法在API 23才有，那我就增加如下的版本判断就好了呀：</p>
<hr>
<pre><code>if (Build.VERSION.SDK_INT &gt;= 23) {
    //call Context#checkSelfPermission
}
</code></pre><hr>
<p>但是，其实您并不能保证其他人在使用你的代码编译的时候的Androi SDK版本一定是≥23的，如果是不≥23的Android SDK版本去编译，编译就挂了。因此为了兼容编译的版本，我们使用反射来调用这个方法，取消方法名的显式调用，这样就不会有找不到这个方法的编译问题。所以现在我们的代码就变成了这样：</p>
<hr>
<pre><code>public static boolean checkSelfPermission(Context context, String permission) {
    boolean permissionGranted = false;
    if (context == null) {
        return false;
    } else {
        if (Build.VERSION.SDK_INT &gt;= 23) {
            try {
                Class clz = Class.forName(&quot;android.content.Context&quot;);
                Method checkSelfPermission = clz.getMethod(&quot;checkSelfPermission&quot;, new
                        Class[]{String.class});
                int i = ((Integer) checkSelfPermission.invoke(context, new
                        Object[]{permission})).intValue();
                if (i == PackageManager.PERMISSION_GRANTED) {
                    permissionGranted = true;
                } else {
                    permissionGranted = false;
                }
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    }
    return permissionGranted;
}
</code></pre><hr>
<p>但是的但是，现在显然这个方法是只能提供给API 23的权限检车使用的，因为进行了版本判断。我们再增加如下的代码片将API 22以及以下的版本给兜住喽：</p>
<hr>
<pre><code>PackageManager packageManager = context.getPackageManager();
if (packageManager.checkPermission(permission, context.getPackageName()) ==
                        PackageManager.PERMISSION_GRANTED) {
    permissionGranted = true;
}
</code></pre><hr>
<p>可能到这里又会有同学问了，既然只是判断是否授权，一个布尔值，那干脆全部使用上述的代码片段就好了哇。确实可以这样的，但是其实根据Support Library中的思路，有新的API，都会面向使用更(gèng)新的API，比如，V4包中的DrawableCompat类，在不同的版本会new不同版本的实例，这里也是一样的，不同版本走不同的逻辑，因此我们最终的权限判断方法就变成了如下的样子（针对if增加了一个else）：</p>
<hr>
<pre><code>public static boolean checkSelfPermission(Context context, String permission) {
    boolean permissionGranted = false;
    if (context == null) {
        return false;
    } else {
        if (Build.VERSION.SDK_INT &gt;= 23) {
            try {
                Class clz = Class.forName(&quot;android.content.Context&quot;);
                Method checkSelfPermission = clz.getMethod(&quot;checkSelfPermission&quot;, new
                        Class[]{String.class});
                int i = ((Integer) checkSelfPermission.invoke(context, new
                        Object[]{permission})).intValue();
                if (i == PackageManager.PERMISSION_GRANTED) {
                    permissionGranted = true;
                } else {
                    permissionGranted = false;
                }
            } catch (Throwable e) {
                e.printStackTrace();
            }
        } else {//新增
            PackageManager packageManager = context.getPackageManager();
            if (packageManager.checkPermission(permission, context.getPackageName()) ==
                    PackageManager.PERMISSION_GRANTED) {
                permissionGranted = true;
            }
        }
    }
    return permissionGranted;
}
</code></pre><hr>
<p>另外，还有最后一点，我们的反射的API在Android中并不是@Hide标记的，因此，按理应不会在以后的Android版本中（比如Android 9.0 中），被禁用。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/10/05/cookies_how_to_get_aar/">[饼干]如何获取官方的aar包</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-05 17:56:20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/programming/">programming</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/cookies/">cookies</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/android/">android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/maven/">maven</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/aar/">aar</a></span><div class="content"><p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>怎么获取开源项目的aar包。</li>
<li>support library的aar包又怎么获取呢。</li>
</ol>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先我们来看看这个问题是如何产生的，因为公司需要配置Jenkins离线打包，具体的操作我也写了一篇博文来描述踩坑过程，<a href="http://halohoop.com/2017/10/05/nothing/">《Ubuntu下结合Github搭建Jenkins自动打Android包》</a>，显然，点进去之后你会发现被我坑了，因为我还时间没写完。</p>
<p>公司需要配置Jenkins离线打包，服务器为了避免编译的时候下载很多的未知的资源，以及缩短编译时间，因此如果安卓的项目中如果在build.gradle中使用compile、api或者implementation引用开源项目的话，比如：</p>
<pre><code>compile &apos;com.android.support:appcompat-v7:26.1.0&apos;
</code></pre><p>如果服务器的sdk中没有下载有这个26版本的库，那么就很可能会导致离线编译不通过，因为专门用于编译工作的服务器有时候是没有必要连接外网的，没有外网就意味着不能够下载相关的引用的资源或者代码，因此我们通常会需要引用的开源项目的aar包，来支持离线编译。<br>然而通过compile、api或者implementation引用开源项目，我们在本地很可能会找不到aar，哪怕在build里面也找不到。<br>这个时候开头说的两个需求就来了。我们当然可以通过下载开源项目的源代码然后手动打aar包<a href="https://www.google.com.hk/search?safe=strict&amp;q=%E6%89%93aar%E5%8C%85&amp;oq=%E6%89%93aar%E5%8C%85&amp;gs_l=psy-ab.12..0i10i42k1.622035.622035.0.622425.1.1.0.0.0.0.264.264.2-1.1.0....0...1.1.64.psy-ab..0.1.262....0.MwxG2Y8zpJE" target="_blank" rel="external">[谷歌一下]</a>的方式来得到，当然我们也可以通过官方的下载渠道得到。接下来就介绍一下如何获取官方的aar包。</p>
<h2 id="获取官方的aar包"><a href="#获取官方的aar包" class="headerlink" title="获取官方的aar包"></a>获取官方的aar包</h2><h3 id="获取开源项目的aar包"><a href="#获取开源项目的aar包" class="headerlink" title="获取开源项目的aar包"></a>获取开源项目的aar包</h3><p>四个步骤，简单到怀疑人生</p>
<ol>
<li>打开链接<br><a href="https://search.maven.org/#search" target="_blank" rel="external">https://search.maven.org/#search</a></li>
<li>搜索开源项目名字<ul>
<li>a. 比如搜索okhttp<br><img src="/2017/10/05/cookies_how_to_get_aar/5eb1829e-63d9-44cd-a217-3355d3f8cfe9.png" alt=""></li>
</ul>
</li>
<li><p>下载</p>
<ul>
<li>a.这里需要说的一点就是，由于有些开源项目比如说squareup的okhttp，只是一个类库，也就是全部都是class文件，因此是不需要打包成aar包的，只需要一个jar包即可。</li>
<li>b.点击对应开源项目的“jar”或者“aar”即可下载到对应版本的，如下图<br><img src="/2017/10/05/cookies_how_to_get_aar/b623fb45-dc06-42f3-bb6f-2a7a01c7ebfd.png" alt=""></li>
<li><p>c.一般这个的版本都是最新发布的版本，如果不是想要的版本的时候，可以点击下图中的“all”，就能够得到所有的已发布的版本，这时候点击对应aar或者jar下载需要的包即可。<br><img src="/2017/10/05/cookies_how_to_get_aar/0ca1de32-e796-4991-9a05-0bf6082c67e9.png" alt=""><br><img src="/2017/10/05/cookies_how_to_get_aar/aad5e099-a4fc-41da-9f3e-3c24ab2491bb.png" alt=""></p>
<h3 id="获取support-library的aar包"><a href="#获取support-library的aar包" class="headerlink" title="获取support library的aar包"></a>获取support library的aar包</h3></li>
<li>比如需要找到appcompat-v7的25.3.1版本，去SDK下相应的文件夹下就能够找到了<ul>
<li>[SDK_DIR]\extras\android\m2repository\com\android\support\appcompat-v7\25.3.1</li>
</ul>
</li>
<li>如果不知道有什么版本怎么办，别怕，谷歌出品必属精品，肯定有迹可循的嘛<ul>
<li>打开这个网址即可查看最近的和最新的发布的支持包版本了：<a href="https://developer.android.com/topic/libraries/support-library/revisions.html" target="_blank" rel="external">Recent Support Library Revisions</a></li>
</ul>
</li>
</ul>
</li>
<li><p>引用</p>
</li>
</ol>
<hr>
<pre><code>//引用aar包配置
dependencies {
    //compile(name: &apos;xxx&apos;, ext: &apos;aar&apos;)
    compile(name:&apos;mylib-release&apos;, ext:&apos;aar&apos;)
}
repositories{
    flatDir{
        dirs &apos;libs&apos;
    }
}
</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>如果想要更加深入拓展研究透彻，推荐可以从这些个方向去深入：</p>
<ol>
<li>如何打aar包。</li>
<li>build.gradle中compile、api或者implementation回来依赖库在本地是以怎么样的形式存在的。<ul>
<li>是一堆的资源文件和*.class文件还是什么？</li>
<li>存在什么目录中？build文件夹中？</li>
<li>难道不是compile引用一个库不是下载其aar包到本地么？</li>
</ul>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/08/08/snacks-wave_float_text_view/">[点心]自定义控件之这文字有点浪-Kotlin实现</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-08 03:03:20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/programming/">programming</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/android/">android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/effect/">effect</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/snacks/">snacks</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/custom-view/">custom_view</a></span><div class="content"><p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>
<p>控件源码：<a href="https://github.com/halohoop/AndroidDigIn#24带文字的波浪" target="_blank" rel="external">https://github.com/halohoop/AndroidDigIn#24带文字的波浪</a></p>
<h2 id="壹-效果图"><a href="#壹-效果图" class="headerlink" title="壹.效果图"></a>壹.效果图</h2><p><img src="/2017/08/08/snacks-wave_float_text_view/device-2017-07-13-004908.gif" alt="demo0"></p>
<h2 id="贰-知识点"><a href="#贰-知识点" class="headerlink" title="贰.知识点"></a>贰.知识点</h2><ul>
<li>1.SurfaceView子线程高效绘制；</li>
<li>2.贝塞尔曲线画波浪；</li>
<li>3.文字测量；</li>
<li>4.Kotlin语法；</li>
<li>5.Region+Path的使用；</li>
</ul>
<h2 id="叁-背景-amp-介绍"><a href="#叁-背景-amp-介绍" class="headerlink" title="叁.背景&amp;介绍"></a>叁.背景&amp;介绍</h2><ul>
<li>给自己的需求是酱的：想要实现一个随着波浪浮动的文字。</li>
<li>可能是因为使用kotlin语法简洁的缘故，代码只有不到400行。</li>
<li>用工的孩子时间都不多，心照啦，所以全文会尽量不说废话或少说废话，先来一句废话，么么哒。</li>
</ul>
<h2 id="肆-使用方式"><a href="#肆-使用方式" class="headerlink" title="肆.使用方式"></a>肆.使用方式</h2><ul>
<li>改变速度，绘制的时候就是根据速度的值来决定波浪移动的距离的，代码见下文的绘制方法</li>
</ul>
<hr>
<pre><code>progress.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener {
    override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) {
        val value = progress.toFloat()
        view.mSpeed = if (value&lt;=0) 1F else value
    }

    ...
})
</code></pre><hr>
<ul>
<li>修改文字，可以看到Kotlin的set我们只需要直接给变量赋值即可。</li>
</ul>
<hr>
<pre><code>view实例.text = &quot;中abcdefghijkl文&quot;

//具体的set、get方法
var text: String = &quot;Halohoop&quot;
    set(value) {
        stopLoopDraw()//先暂停
        lock(lockObj,{
            field = value
            val textPosMidX = mMidX;
            updateTextsConfigs(value, textPosMidX)
        })
        startLoopDraw()//重新开始
    }
    get
</code></pre><hr>
<h2 id="伍-拆解轮子"><a href="#伍-拆解轮子" class="headerlink" title="伍.拆解轮子"></a>伍.拆解轮子</h2><h3 id="1-绘制波浪。"><a href="#1-绘制波浪。" class="headerlink" title="1.绘制波浪。"></a>1.绘制波浪。</h3><ul>
<li>准备波浪Path<ul>
<li>如下图，不管你屏幕中画多少个周期，你给我<strong>画多一个周期</strong>出来用作移动就好了，每次朝一个方向移动完一个周期就重置。</li>
<li><img src="/2017/08/08/snacks-wave_float_text_view/demo1.png" alt="demo1"></li>
<li>取巧的方法是Path.rQuadTo方法，而不是直接用Path.quadTo，因为可以相对于上一个Path移动到的位置作为起点。</li>
<li>看码</li>
</ul>
</li>
</ul>
<hr>
<pre><code>private fun drawWave(canvas: Canvas?) {
    paint.color = WAVE_COLOR
    val quaterWaveWidth = mHalfWaveWidth / 2f;//四分之一个周期

    path.rewind()//重置path，清空路径

    val dx = mDx;//移动的距离
    path.moveTo(0f - mHalfWaveWidth * 2f + dx, mMidY)//移动到开始点

    for (i in 0..mWaveCount) {
        path.rQuadTo(quaterWaveWidth, mWaveHeight, mHalfWaveWidth, 0f)
        path.rQuadTo(quaterWaveWidth, -mWaveHeight, mHalfWaveWidth, 0f)
    }

    path.lineTo(measuredWidth.toFloat(), measuredHeight.toFloat())//和右下角连接起来
    path.lineTo(0f, measuredHeight.toFloat())//和左下角连接起来
    path.close()//封闭起来

    canvas?.drawPath(path, paint)
}
</code></pre><hr>
<h3 id="2-拆解文字，得到文字绘制的区域Rect。"><a href="#2-拆解文字，得到文字绘制的区域Rect。" class="headerlink" title="2.拆解文字，得到文字绘制的区域Rect。"></a>2.拆解文字，得到文字绘制的区域Rect。</h3><ul>
<li>看码，你应该注意到方法中又定义方法，这是Kotlin特性，就是这么任性，抄抄JavaScript有时还抄抄C++抄抄Groovy…</li>
<li>看码中注释即可，不废话</li>
</ul>
<hr>
<pre><code>//用于计算文字位置的Region集合
private var mTextPositionHelperRegions: ArrayList&lt;Region&gt;? = null
//每个文字的宽度数组
private lateinit var mEveryLetterWidths: FloatArray
...
@MainThread
private fun updateTextsConfigs(newText: String, textPosMidX: Float) {

    //获取每个文字的宽度
    fun getEveryLetterWidth(text: String) : FloatArray{
        mEveryLetterWidths = FloatArray(text.length)
        textPaint.getTextWidths(text, 0, text.length, mEveryLetterWidths)
        return mEveryLetterWidths
    }

    //得到所有文字的总宽
    fun getHowWidthOfTexts(everyLetterWidths: FloatArray): Float {
        mHowWidthOfTexts = 0f;
        everyLetterWidths.forEach { mHowWidthOfTexts += it }
        return mHowWidthOfTexts
    }

    //得到所有的文字的绘制区域，放入集合中
    fun updateTextPositionHelperRegions(textPosMidX: Float = 0f, howWidthOfTexts: Float,
                                                everyLetterWidths: FloatArray) {
        val startX = textPosMidX - howWidthOfTexts / 2
        val tmpEveryLetterWidths = everyLetterWidths
        var tmpHowWidthOfTexts = howWidthOfTexts
        val lettersCount = tmpEveryLetterWidths.size

        if (mTextPositionHelperRegions != null) {
            mTextPositionHelperRegions!!.clear()
            mTextPositionHelperRegions = null
        }
        mTextPositionHelperRegions = ArrayList&lt;Region&gt;()

        for (i in lettersCount - 1 downTo 0) {//倒序遍历每个字
            if (tmpHowWidthOfTexts &lt; 0) tmpHowWidthOfTexts = 0f
            tmpHowWidthOfTexts -= tmpEveryLetterWidths[i]
            val region = Region((startX - 1 + tmpHowWidthOfTexts).toInt(), 0,
                    (startX + tmpHowWidthOfTexts).toInt(), measuredHeight)
            mTextPositionHelperRegions!!.add(0, region)//往最前面插
        }
    }

    val everyLetterWidths = getEveryLetterWidth(newText)
    //get how width of texts
    val howWidthOfTexts = getHowWidthOfTexts(everyLetterWidths)
    //initialize TextPositionHelperRegions
    updateTextPositionHelperRegions(textPosMidX, howWidthOfTexts, everyLetterWidths)
}
</code></pre><hr>
<h3 id="3-通过region得到波浪Path上的x，y坐标，将文字画出来。"><a href="#3-通过region得到波浪Path上的x，y坐标，将文字画出来。" class="headerlink" title="3.通过region得到波浪Path上的x，y坐标，将文字画出来。"></a>3.通过region得到波浪Path上的x，y坐标，将文字画出来。</h3><hr>
<pre><code>private fun drawTexts(canvas: Canvas?) {
    textPaint.color = TEXT_COLOR
    var i = 0
    val toCharArray = text!!.toCharArray()
    mTextPositionHelperRegions?.forEach {
        //以下这句是得到波浪上点的关键
        //会往it,也就是mTextPositionHelperRegions的一个元素Region里面塞入裁剪之后的Rect
        mRegion.setPath(path, it)//里面记录了Path和Region相交的四个方向的最值。
        if (DEBUG) {
            //debug
            canvas?.drawRect(it.bounds, textPaint)
        }

        //使用左和上值绘制文字
        canvas?.drawText(toCharArray[i] + &quot;&quot;, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat(), textPaint)
        if (DEBUG &amp;&amp; i == 0) {
            canvas?.drawText(text, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat() - 100, textPaint)
        }
        i++
    }
}
</code></pre><hr>
<h3 id="4-设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“-”拒绝kotlin帮你做好的空指针危险限制。"><a href="#4-设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“-”拒绝kotlin帮你做好的空指针危险限制。" class="headerlink" title="4.设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“!!”拒绝kotlin帮你做好的空指针危险限制。"></a>4.设置动画动起来和停下，当你非常确定一个变量不为空的时候可以加入“!!”拒绝kotlin帮你做好的空指针危险限制。</h3><hr>
<pre><code>fun startFlow() {
    stopFlow()
    flowAnimator = ValueAnimator.ofFloat(0f, mHalfWaveWidth * 2)
            .setDuration(1000)
    flowAnimator!!.setRepeatMode(ValueAnimator.RESTART)
    flowAnimator!!.setRepeatCount(ValueAnimator.INFINITE)
    flowAnimator!!.interpolator = LinearInterpolator()
    flowAnimator!!.addUpdateListener {
        mDx = it.animatedValue as Float
        this@WaveWithTextView.invalidate(0, (mMidY - mWaveHeight).toInt(), measuredHeight, (mMidY + mWaveHeight).toInt())
    }

    flowAnimator!!.start()
}

fun stopFlow() {
    if (flowAnimator != null &amp;&amp; flowAnimator!!.isRunning &amp;&amp; flowAnimator!!.isStarted) {
        flowAnimator!!.cancel()
        flowAnimator = null
    }
}
</code></pre><hr>
<h3 id="5-使用SurfaceView子线程绘制实现。"><a href="#5-使用SurfaceView子线程绘制实现。" class="headerlink" title="5.使用SurfaceView子线程绘制实现。"></a>5.使用SurfaceView子线程绘制实现。</h3><ul>
<li>5.1.这里贴出关键绘制线程run方法代码：<ul>
<li>其中是抽象方法onThreadRenderDraw，负责使用给的Canvas绘制工作，执行在子线程中.</li>
<li>更多详情请参阅BaseSurfaceWaveWithTextsViewKotlin原码。</li>
</ul>
</li>
</ul>
<hr>
<pre><code>override fun run() {
    val startTime = System.currentTimeMillis()
    while (true) {
        if (!mIsRunning) {//控制是否开始波浪起伏
            Log.i(&quot;halohoop&quot;, &quot;Halohoop--&quot; + &quot;stop&quot;)
            break
        }
        val canvas = mSurfaceHolder.lockCanvas()
        if (canvas != null) {
            lock(lockObj, {
                if (mIsRunning) {
                    onThreadRenderDraw(canvas, System.currentTimeMillis() - startTime)
                }
            })
            //绘制完成
            mSurfaceHolder.unlockCanvasAndPost(canvas)
        }
        try {
            Thread.sleep(SLEEP_TIME)//用于保证和垂直刷新信号同步的时间差
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
    }
}
...
companion object {
    private val SLEEP_TIME: Long = 16//毫秒
}
...
//其中onThreadRenderDraw是基类的抽象方法，
//具体需要话什么需要子类自己去实现
//并且这个方法是在子线程中进行绘制的。
@WorkerThread
protected abstract fun onThreadRenderDraw(canvas: Canvas, l: Long)
</code></pre><hr>
<ul>
<li>5.2.多线程加锁工具方法，由于涉及线程因此一些关键状态的修改需要加锁</li>
</ul>
<hr>
<pre><code>fun &lt;T&gt; lock(lock: Lock, body: () -&gt; T) {//为了加锁方便，定义了一个加锁工具方法
    lock.lock()
    try {
        body()
    }
    finally {
        lock.unlock()
    }
}
...
//使用示例
override fun surfaceDestroyed(holder: SurfaceHolder) {
    lock(lockObj,{
        stopLoopDraw()
    })
}
</code></pre><hr>
<ul>
<li>5.3.具体的绘制过程</li>
</ul>
<hr>
<pre><code>override fun onThreadRenderDraw(canvas: Canvas, l: Long) {
    canvas.drawColor(Color.WHITE)

    //当你单位时间水平方向的移动距离越大时候，速度就越快
    mDx += mSpeed
    if (mDx &gt;= mHalfWaveWidth * 2) {
        mDx = 0f
    }

    if (DEBUG) {
        canvas?.drawLine((measuredWidth shr 1).toFloat(), 0f,
                (measuredWidth shr 1).toFloat(), measuredHeight.toFloat(), paint)
    }

    drawTexts(canvas)//画文字
    drawWave(canvas)//画波浪

}

//没什么可说的，一目了然的命名
private fun drawWave(canvas: Canvas?) {
    paint.color = WAVE_COLOR
    val quaterWaveWidth = mHalfWaveWidth / 2f;

    path.rewind()//清空旧path

    val dx = mDx;
    path.moveTo(0f - mHalfWaveWidth * 2f + dx, mMidY)

    for (i in 0..mWaveCount) {
        path.rQuadTo(quaterWaveWidth, mWaveHeight, mHalfWaveWidth, 0f)
        path.rQuadTo(quaterWaveWidth, -mWaveHeight, mHalfWaveWidth, 0f)
    }

    path.lineTo(measuredWidth.toFloat(), measuredHeight.toFloat())
    path.lineTo(0f, measuredHeight.toFloat())
    path.close()

    canvas?.drawPath(path, paint)
}

private fun drawTexts(canvas: Canvas?) {
    textPaint.color = TEXT_COLOR
    var i = 0
    val toCharArray = text!!.toCharArray()
    mTextPositionHelperRegions?.forEach {
        //kotlin的forEach遍历可以使用it来接收每一轮遍历的结果
        mRegion.setPath(path, it)
        //当一个Region和path相交的时候
        //这个path在这个region中被用一个Rect来描述，也就是下面的bounds
        //因此就能够得到这个path被region裁剪之后四边之最，左上右下
        if (DEBUG) {
            //debug
            canvas?.drawRect(it.bounds, textPaint)
        }

        canvas?.drawText(toCharArray[i] + &quot;&quot;, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat(), textPaint)
        if (DEBUG &amp;&amp; i == 0) {
            canvas?.drawText(text, it.bounds.left.toFloat(), mRegion.bounds.top.toFloat() - 100, textPaint)
        }
        i++
    }
}
</code></pre><hr>
<h2 id="陆-新需求迭代展望："><a href="#陆-新需求迭代展望：" class="headerlink" title="陆.新需求迭代展望："></a>陆.新需求迭代展望：</h2><ul>
<li>1.支持使用图片替换文字。</li>
<li>2.添加TextureView的版本，因为TextureView可以做view的动画。</li>
<li>3.加入角度的旋转，打造文字随着波浪的切线摆动，会更加真实，欢迎继续关注。</li>
</ul>
<h2 id="柒-最后"><a href="#柒-最后" class="headerlink" title="柒.最后"></a>柒.最后</h2><p>声明：此控件没有经过完整测试，纯练手控件，不要随便在项目中使用，请自行完善。<br>思想为主，知识为辅，Coding随后。<br>如果读者还有不明朗的地方，欢迎查看源码，并且给我提bug，一起为这个社区做出自己的微薄贡献。</p>
<p>控件源码：<a href="https://github.com/halohoop/AndroidDigIn#24带文字的波浪" target="_blank" rel="external">https://github.com/halohoop/AndroidDigIn#24带文字的波浪</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/08/05/dewdrops-peace_in_your_heart/">[露水]做技术，浮躁的人那么多，踏实的人那么少</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-05 03:39:02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/tricks/">tricks</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/dewdrops/">dewdrops</a></span><div class="content"><p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>
<p>浮躁的人太多，加之网络键盘侠太多，动动手指，就能发泄自己的不满、自己的脾气，惯用自以为看清了一切的口气说话。</p>
<p>天天忙的事情就是发现谁在装逼，然后自己又配合装逼来应和一下，在真实的世界实际的人际交往的时候或者相互认识的网络群中，这个举措或许会很有用，因为能够拉近彼此间的距离，但是彼此互相都不认识在网络世界的交流，一点用都没有的，至少我是这么认为的，如果说有那肯定也只是yy出来的有用罢了，所以说不要做这样的人，这样的人太浮躁，做技术就重要的就是真诚、落地和专注，而不是轻易的就被一件事情吸引，心生杂念。</p>
<p>经常看见身边的或者是各种技术群里的人，看到一个人知道自己不知道的，就想要去做比较，想要比较这个和自己出现在同一个平台上的人是不是比自己学会的更多，想要知道到底他是怎么知道的，为什么会知道，久而久之，变成了“他怎么可能会比我还知道”，养成了容易心生嫉妒的习惯，嘴上称赞心理却很嫉妒，于是处处攀比，无法自拔，浮躁由此而生。</p>
<p>细想，这可能是技术圈里很容易出现的一种情况，原因我想可能就是因为技术圈的快节奏以及高复杂度。<br>快节奏，只要你不是个无理想的富二代，那“不甘落后于别人”以及“危机感”就是你在这个社群中固有的属性，落后于是追赶，被追上于是加速，于是我们的圈子节奏越来越快。<br>高复杂度，就是说技术圈中技术成百上千，就拿计算机语言来说，榜上有名的<a href="https://www.tiobe.com/tiobe-index//programming-languages-definition/#instances" target="_blank" rel="external">语言</a>就有200+种，每一种都是一个世界，这些世界或多或少的又可以相互沟通，每个人都会出现在这些大大小小世界中的某一片天空下，所以我享受的云彩可能在你的位置享受不到，反之亦然，因此出现“你了解的可能我不了解，我了解的可能你不了解”是很正常的。</p>
<p>所以说网络上就出现了“程序员之间的鄙视链”.做技术的人不要总觉得比别人高人一等，不要觉得自己比别人聪明、比别人有优势，我觉得这是最没有用的，把姿态放的足够低，厚积薄发才是真正应该做的。</p>
<p>再举个例子，有一句话是这么说的，“不能适应改需求的设计不是好设计”，不同的人对这句话的理解和体会可能会不一样，积极踏实的人，“哎！确实是这么回事，我要努力达到这个境界”，消极浮躁的人，“我艹，这肯定是产品说出来的话，不是程序猿说的”，你看，已相差甚远。只有积极踏实的人才能够真正从不好中发现美好和对自己的有意义的细节。</p>
<p>我写这篇的目的不是为了说明自己做的有多么好，我只是觉得我很庆幸已经有这种觉悟并且觉得有义务分享出来罢了。</p>
<p>————卖牙膏的芖口钉</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/07/16/snacks_shortcuts_of_as/">[点心]Android Studio快捷键这篇就够了</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-16 03:03:20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/programming/">programming</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/android/">android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/snacks/">snacks</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/shortcuts/">shortcuts</a></span><div class="content"><p><strong><em>声明：博文未经授权一律不允转载</em></strong></p>
<h2 id="update-log"><a href="#update-log" class="headerlink" title="update log"></a>update log</h2><ul>
<li>20170721 <ul>
<li>+Esc取消选中</li>
</ul>
</li>
<li>20170819<ul>
<li>+选中方法的更加快捷的方式,Ctrl + W,搜索[方法选中]</li>
<li>+用键盘键盘新建一个文件的更加快捷方式,Alt + insert,搜索[用键盘键盘新建一个文件的更加快捷方式]</li>
</ul>
</li>
</ul>
<p>##</p>
<p><strong>将需要精确点击的事情，变得不需要精确，甚至是随机（有规则的随机，但是遵守这个规则是人的轻易就能做到的），让计算机来处理这种随机，那你的效率将会提高很多很多。</strong></p>
<p><strong><em>————来自 卖牙膏霸气侧漏农村有文化的芖口钉（Halohoop）语录</em></strong></p>
<p>(Yeah,I said that.😄)</p>
<p>举个例子，一个界面窗口需要点击一个叉叉才能关闭，然后如果你能够使用一个手势，比如左滑或者右滑（有规律的随机，随便一个地方左/右滑动）来关闭这个窗口，那么效率就得到了提升，随之而来的也会是更好的用户体验，而快捷键和手势都是一种提效方式，废话不多说，接下来就来看我在AS中漂亮的回旋踢吧。</p>
<p>文章可能是“关公面前耍大刀，包公面前晒太阳，老干妈面前吃辣条”，不是大佬的都共勉，是大佬的话就当笑话看吧，哇哈哈哈哈哈刀哈哈哈哈哈哈!!!</p>
<p>另外，快捷键只有当你真正体会到它的方便之处，并且熟练操作了之后才能真正提高你的效率，如果觉得自己现在挺好的没什么必要的知道，可以跳过这个文章了哦，节省时间哇。.</p>
<p>再另外，为了让读者有环环相扣的情景感，下文使用顶针的方式来写。并且涉及到代码的部分全都使用Kotlin。<br>（顶针的修辞手法：每段末尾和下一段开头呼应）</p>
<hr>
<p>本文快捷键基于windows版本AS，如果你已经修改过一些快捷键，本文的一些快捷键可能会失效。</p>
<p>前面略显拖沓，故事现在从这里开始。</p>
<h2 id="1-“Alt-F1，1（Alt-F1，直接再按1）”"><a href="#1-“Alt-F1，1（Alt-F1，直接再按1）”" class="headerlink" title="1.“Alt + F1，1（Alt + F1，直接再按1）”"></a>1.“Alt + F1，1（Alt + F1，直接再按1）”</h2><p>相信我们都会使用到这个按钮，“Scroll from Source”</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic1.png" alt="图1"></p>
<p>可以帮我们找到正在编辑的文件所在项目的位置，在项目越来越复杂文件越来越多的时候是非常有用的，可是那么小的按钮，我真的不想再用鼠标去缓慢的<strong>精确定位</strong>再点击，显然这个问题巨人也遇到了，于是巨人给我们了一个“Alt + F1，1”。鼠标焦点在代码编辑界面的时候，“Alt + F1，1（Alt + F1，直接再按1）”。</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic2.png" alt="图2"></p>
<p>可以发现这个Alt + F1之后弹出的窗口里面可不止这一个快捷键，比如，第8和第0都非常好用的咧。</p>
<p>[用键盘键盘新建一个文件的更加快捷方式]<br>当我们焦点处于[1.Project]方法的时候，可以使用上下左右键将选中的项目定位在一个文件夹，然后按键盘“Alt + Insert”按键，就会有“Alt + F”的效果，但是弹出的菜单会更容易新建一个文件，去体会一下吧。</p>
<p>好了，现在窗口的焦点到了[1.Project]这个模块中了，我们定位到了源文件的位置了，现在想要回到刚才代码焦点编辑的地方，显然我又想拒绝鼠标了，于是巨人给我们了一个“Esc”。</p>
<p>鉴于下文也会用到“于是巨人给了我们一个”，因此定义如下：</p>
<pre><code>val 于巨给个 = “于是巨人给了我们一个”//上帝说有光，那就有光了，哈哈哈
</code></pre><hr>
<h2 id="2-“Esc”"><a href="#2-“Esc”" class="headerlink" title="2.“Esc”"></a>2.“Esc”</h2><p>移动鼠标+点击的速度当然比不上我按一个Esc的速度，按下Esc，于是我们又回到了最初代码编辑的地方。<br>这个快捷键不仅在[1.Project]这个模块中是有用的，在很多界面你按Esc都是可以回到编辑窗口区域的，但是有些就不行，我知道的就是Terminal终端窗口中按Esc是回不去的，这个Terminal终端窗口下文也会提到。</p>
<p>另外一个就是当你选中一堆代码的时候，你按“Esc”也会有取消选中的作用，这个稍微提一下就可以了。</p>
<p>好了，既然回到代码区域，现在我们开始畅游代码世界，突然间，偶遇这一个代码段：</p>
<pre><code>//来自android.view.ViewGroup#dispatchTouchEvent
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
        //此处省略200+行代码..
        return handled;
}
</code></pre><p>相信只要不是竖屏的显示器都显示不全这个方法，必须要手动滚动鼠标才能看完，一般我们看源码想要加注释的话会将其拷贝出来到一个同名类中进行，拷贝这个动作则又是一个耗时操作，因为方法有200+行，需按着鼠标不松开，然后滚轮，于巨给个“Ctrl + Shift + ]”等。</p>
<hr>
<h2 id="3-“Ctrl-左或右”、“Ctrl-或-”-和-“Shift-上下左右“-以及它们的合体-“Ctrl-Shift-或-“和“Ctrl-Shift-左或右”"><a href="#3-“Ctrl-左或右”、“Ctrl-或-”-和-“Shift-上下左右“-以及它们的合体-“Ctrl-Shift-或-“和“Ctrl-Shift-左或右”" class="headerlink" title="3.“Ctrl + 左或右”、“Ctrl + [ 或 ]” 和 “Shift + 上下左右“ 以及它们的合体 “Ctrl + Shift + [ 或 ]“和“Ctrl + Shift + 左或右”"></a>3.“Ctrl + 左或右”、“Ctrl + [ 或 ]” 和 “Shift + 上下左右“ 以及它们的合体 “Ctrl + Shift + [ 或 ]“和“Ctrl + Shift + 左或右”</h2><p>说明这些个快捷键之前，我先定义几个点：</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic3.png" alt="图3"></p>
<p>首先我们来解决上一小节的问题，快速复制整个方法，假设我们光标已经在第k行了，</p>
<ul>
<li>那么现在按home键，去到开头，也就是public的左边</li>
<li>然后现在按Ctrl + Shift + ]，会发现从public到点b撇的位置都被选中了，然后我们再使用Shift + →，把最后的花括号选中，然后Ctrl + C那就大功告成了，别看这一段文字挺多的，熟练操作之后这个复制的操作应该只需要1秒。</li>
<li>但是，这里要说明的是，并不是说鼠标就不好，只是知道键盘的操作可能会提高我们的效率罢了，单单看这个需求，可能鼠标会比我们更快也说不定，因为如果你在点a或者点a撇双击左键的话，点a到点a撇之间的内容就能够被选中了(点b和点b撇也是)。</li>
<li>当然光标在点a或者点b的时候按“Ctrl + W”也是能够将方法选中的[方法选中]。</li>
<li><p>但是如果要把上面的“@Override”也复制上，那就还是需要使用组合的快捷键比较好了。</p>
<ul>
<li>首先定位到k-1行；</li>
<li>home到开头第一个字母；</li>
<li>Shift + ↓选中k-1行，这时候光标在public开头；</li>
<li>然后重复上文提到的步骤即可；</li>
<li>文字虽长，但操作是瞬时的，重在体会快捷键设计的艺术；</li>
</ul>
</li>
<li><p>“Ctrl + 左或右”：按词移动光标</p>
</li>
<li>“Ctrl + [ 或 ]”：寻找花括号及花括号的兄弟</li>
<li>“Shift + 上下左右”：左右上下选中</li>
<li>“Ctrl + Shift + [ 或 ]”：寻找花括号及花括号的兄弟 + 选中</li>
<li>“Ctrl + Shift + 左右”：按词移动光标 + 选中</li>
</ul>
<p>很容易发现，加了Shift就有了选中功能，没加就是移动光标功能。</p>
<p>好了，现在我们继续畅游ViewGroup#dispatchTouchEvent方法，使用<strong>“↑/↓方向键”</strong>一行行的过，使用<strong>“Ctrl + ↑/↓”</strong>一行行的滚动屏幕，突然间我们发现我们找到了onInterceptTouchEvent方法：</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic4.png" alt="图4"></p>
<p>想要进去看看，然后想必我们下意识的操作肯定是，按住Ctrl，另一只手点击鼠标左键，虽然这个操作也很6，但是如果没有鼠标咧？于巨给个<strong>“F4”</strong>。</p>
<hr>
<h2 id="4-“F4”"><a href="#4-“F4”" class="headerlink" title="4.“F4”"></a>4.“F4”</h2><p>焦点在方法或者变量上的时候，按“F4”能够找到它们定义的位置。</p>
<p>按“F4”，于是我们咻的一下去到了onInterceptTouchEvent的定义处：</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic5.png" alt="图5"></p>
<p><strong><em>说到这里，我要重新提一下我开头的那句话儿了，上面包括下面会提到的快捷键无不例外的都遵循了我说的规律，那就是将需要手指精确定位或者人眼去找的部分去除掉，利用计算机的高速运算能力，比如说，“Ctrl + [”帮我们找到“}”的同组“{”在哪里，或者“Ctrl + F12”，匹配有相同关键字的方法，缩小肉眼观察的范围……等等.</em></strong></p>
<p>好了回来，我们暂且不考虑onInterceptTouchEvent的if条件中更深的方法调用，所以这里就一个判断一眼扫过，onInterceptTouchEvent执行完就出栈了，这时候我们想要回到dispatchTouchEvent方法中继续看其下面的流程，dispatchTouchEvent和onInterceptTouchEvent隔了好几百行代码，我们可以通过<strong>“Ctrl + F12”</strong>然后输入dispatchTouchEvent前面几个字符，快速找回dispatchTouchEvent，但是还是太慢，因为还要肉眼去定位dispatchTouchEvent中调用onInterceptTouchEvent的位置，于巨给个<strong>“Ctrl + Alt + ←/→”</strong>。</p>
<hr>
<h2 id="5-“Ctrl-Alt-←-→”，光标位置的历史列表预览器"><a href="#5-“Ctrl-Alt-←-→”，光标位置的历史列表预览器" class="headerlink" title="5.“Ctrl + Alt + ←/→”，光标位置的历史列表预览器"></a>5.“Ctrl + Alt + ←/→”，光标位置的历史列表预览器</h2><p>我们按“Ctrl + Alt + ←”一下或者多下，按多下因为可能在找到onInterceptTouchEvent之后又按了鼠标好几下，如果每次点击位置都不一样，那么每次都会生成一个新历史位置数据，我想这个历史列表的Bean的数据结构很有可能是酱的：</p>
<pre><code>data class CursorBean(var 什么文件: File, var 第几行: Int, var 第几列: Int)
</code></pre><p>当然这个快捷键的按钮位置就在菜单工具栏，如下图：</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic6.png" alt="图6"></p>
<p>当我们悬停在按钮上面的时候，就会发现它的快捷键被提示出来了，所以悬停肯定可以是我们获取快捷键的一条有效路径。</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic7.png" alt="图7"></p>
<p>现在为了更加直观的看到dispatchTouchEvent和onInterceptTouchEvent以及onTouchEvent三个方法的执行顺序或者情况，我们想要在其中加log，因此我们需要新建一个ViewGroup类来进行，首选FrameLayout，用鼠标在对应包名右键新建或者是用鼠标点击File - New - Kotlin File/Class，都显得比较迟缓，或许你知道快捷键是“Alt + F，打开File菜单，然后使用上下左右键选择”，但是这个还是需要手动区定位，略显拖沓，于巨给个“Ctrl + Shift + A”。</p>
<hr>
<h2 id="6-“Ctrl-Shift-A”，通往全世界的任意门"><a href="#6-“Ctrl-Shift-A”，通往全世界的任意门" class="headerlink" title="6.“Ctrl + Shift + A”，通往全世界的任意门"></a>6.“Ctrl + Shift + A”，通往全世界的任意门</h2><p>想要新建一个Kotlin源代码文件MyFrameLayout.kt，只需按下“Ctrl + Shift + A”，然后输入模糊匹配的英文单词即可，比如说“new class”、“kotlinclass”等，然后你只需要在匹配出来的列表中选中“Kotlin File/Class”即可快速新建一个kt源代码文件了。</p>
<p>实际情况中可能你还需要将这个新建的源代码文件放到新的包下，于是看我下面这一波操作：</p>
<ul>
<li>用上面讲过的“Scroll from Source”快捷键，“Alt + F1，1（Alt + F1然后再按1）”，定位到源代码文件；</li>
<li>使用上下左右方向键定位到需要新建新包的包位置；<ul>
<li>上下是切换到上下行，左右则是关闭和打开目录（如果是目录的话）；</li>
</ul>
</li>
<li>这个时候按“Ctrl + Shift + A”，再输入“new packa”，这时候你可以看到“Directory/Package”出现了，直接回车，如果不是出现再第一个那就上下调整一下选中再回车。这时候输入想要新建的包名再回车即可。</li>
<li>这时候会自动选中新建的包，这个时候再来“Ctrl + Shift + A”，输入“new class”或者“kotlinclass”随你便，接下去的事就和刚才新建包一样了。</li>
<li>新建完MyFrameLayout.kt源文件，也会自动帮我们定位到编辑区的。</li>
<li>敲入“class myfram”，根据提示完成补全即可，继承“FrameLayout”实现构造函数什么的我就不过多赘述了，都是“Alt + Enter”的事儿。</li>
</ul>
<p>“Ctrl + Shift + A”是通往全世界的任意门，除了上述的功能，输入任意的快捷键名字、菜单名字、窗口名字等，都能帮你列出来当成一条捷径。</p>
<p>好现在我们的代码到了这一步：</p>
<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr)
</code></pre><p>这个时候很有可能我们的光标不在末尾，而是在这一行的某一个位置，如果你是用“Alt + Enter”辅助完成构造的编写的话，光标会在“FrameLayout”的位置，我们需要在末尾添加花括号对，于是我们先按“end”，然后…好麻烦哦。于巨给个“Ctrl + Shift + 回车”。</p>
<hr>
<h2 id="7-“Ctrl-Shift-回车”，自动补全代码"><a href="#7-“Ctrl-Shift-回车”，自动补全代码" class="headerlink" title="7.“Ctrl + Shift + 回车”，自动补全代码"></a>7.“Ctrl + Shift + 回车”，自动补全代码</h2><p>按下“Ctrl + Shift + 回车”之后会发现代码自动加上花括号了，并且光标定位到我们需要的位置了:</p>
<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr) {
    |←光标位置
}
</code></pre><p>不仅是这里的花括号，如果我们写的是java代码，这个快捷键还会帮我们补全补全末尾的分号，然后将光标自动移动到下一行的对齐的位置。</p>
<p>然后现在我们挨个输入方法名的前几个字母根据提示重写上文中提到的dispatchTouchEvent和onInterceptTouchEvent以及onTouchEvent三个方法：</p>
<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr) {
    override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean {
        return super.onInterceptTouchEvent(ev)
    }

    override fun onTouchEvent(event: MotionEvent?): Boolean {
        return super.onTouchEvent(event)
    }

    override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {
        return super.dispatchTouchEvent(ev)//这一行是被选中的状态，并且光标是在开头
    }
}
</code></pre><p>这时候dispatchTouchEvent中的return语句整行应该是被选中状态的，并且光标处在开头，我们按一下“home”取消选中，让光标停留在“return”前面，现在我们想要直接往上面插入一行，于巨给个“Ctrl + 回车”。</p>
<hr>
<h2 id="8-“Ctrl-回车”，将光标处以后的代码移到下一行去，“Ctrl-Alt-回车”"><a href="#8-“Ctrl-回车”，将光标处以后的代码移到下一行去，“Ctrl-Alt-回车”" class="headerlink" title="8.“Ctrl + 回车”，将光标处以后的代码移到下一行去，“Ctrl + Alt + 回车”"></a>8.“Ctrl + 回车”，将光标处以后的代码移到下一行去，“Ctrl + Alt + 回车”</h2><p>现在单看dispatchTouchEvent方法，应该是这个样子的：</p>
<pre><code>override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {
    |←光标位置
    return super.dispatchTouchEvent(ev)
}
</code></pre><p>另外我们还可以使用“Shift + 回车”，往下面插入一行，“Shift + 回车”支持光标不在行末尾就能够快速向下插入新的一行，这个我相信很多人知道啦。</p>
<p>当然有下必有上，为了能够快速向上插入新的一行，于巨给个“Ctrl + Alt + 回车”，那么我们其实从开头就可以使用这个快捷键，而不需要按一下“home”取消选中了。</p>
<p>现在我们将log打印代码加好，现在得到如下：</p>
<p>Commons.kt：</p>
<pre><code>val TAG = &quot;Halohoop&quot;

inline fun String.logMe(filter: String = &quot;&quot;) {
        Log.i(TAG, TAG + &quot;--&quot; + filter + toString())
}
</code></pre><p>MyFrameLayout.kt：</p>
<pre><code>class MyFrameLayout(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : FrameLayout(context, attrs, defStyleAttr) {
    override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean {
        &quot;onInterceptTouchEvent&quot;.logMe()
        return super.onInterceptTouchEvent(ev)
    }

    override fun onTouchEvent(event: MotionEvent?): Boolean {
        &quot;onTouchEvent&quot;.logMe()
        return super.onTouchEvent(event)
    }

    override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {
        &quot;dispatchTouchEvent&quot;.logMe()
        return super.dispatchTouchEvent(ev)
    }
}
</code></pre><p>现在突然我发现我想要加个过滤字符串“–Road1–”，好让我们在monitor中看的更清楚，当然我们可以打好，然后复制挨个粘贴过去。但是这里我要介绍一个比较好用的功能，IntelliJ IDEA的多光标功能功能，鼠标点击第一个光标需要去到的位置，然后现在按着“Alt + Shift”不放开，用鼠标点击其他的光标位置：</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic8.gif" alt="图8"></p>
<p>现在我们想要研究一下onInterceptTouchEvent的相关流程，于是我们又覆盖这个方法：</p>
<pre><code>override fun requestDisallowInterceptTouchEvent(disallowIntercept: Boolean) {
    &quot;requestDisallowInterceptTouchEvent&quot;.logMe()
    super.requestDisallowInterceptTouchEvent(disallowIntercept)
}
</code></pre><p>当我们写的方法越来越多的时候，不考虑使用鼠标的情况下，想在类中肆意的穿梭，我们使用键盘的上下所有键一行行一个个字母，略显笨拙，于巨给个“好几个快捷键呢，请看下节”。</p>
<hr>
<h2 id="9-“Alt-上下”：成员变量之间穿梭，“Ctrl-F12”：模糊匹配查找成员，“Ctrl-F11、F11、Shift-F11”：书签功能"><a href="#9-“Alt-上下”：成员变量之间穿梭，“Ctrl-F12”：模糊匹配查找成员，“Ctrl-F11、F11、Shift-F11”：书签功能" class="headerlink" title="9.“Alt + 上下”：成员变量之间穿梭，“Ctrl + F12”：模糊匹配查找成员，“Ctrl + F11、F11、Shift + F11”：书签功能"></a>9.“Alt + 上下”：成员变量之间穿梭，“Ctrl + F12”：模糊匹配查找成员，“Ctrl + F11、F11、Shift + F11”：书签功能</h2><p>一般这些快捷键都是穿插着使用的，这里不好用语言描述，读者可以去试试，“Ctrl + F12”相信大家都知道，就像Eclipse中的“Ctrl + O”。</p>
<p>不过我要特别说一下这个书签功能，“F11”是给当前行加一个书签，按下之后你会看到在平时你打断点的位置旁边会出现一个对勾；那么除了对勾之外还可以使用“Ctrl + F11”选择“0-9和A-Z”其中一个标记作为当前标签，按键盘对应英文字母即可，这个时候对勾被换成了对应的字母。然后我们可以使用“Shift + F11”将打开书签列表，可以进行书签的更改，当然直接在当前行按“F11”取消书签也是可以的。</p>
<p>书签这个功能很实用，提供“0-9和A-Z”的书签目的是什么，读者可以站在IDE设计者的角度揣摩一下，为了方便开发者看代码，这个书签设计很棒棒，我个人常常使用这个作为标记以及跟踪源码的这个调用链，在单单就某一块知识（比如说事件分发）进行研究的时候，10+26个书签应该是非常非常够用的了。</p>
<p>好了现在再回到我们的场景中，假设现在我们已经为我们的MyFrameLayout类加了非常多的log信息了，我们定义的String的内联方法“logMe()”在太多地方调用到了，我们需要删除一些，我们通常的做法可能是这样，在logMe的定义处，按着“Ctrl”然后点击鼠标左键就会出现调用“logMe()”的代码行列表了，不用鼠标怎么操作，于巨给个“Ctrl + Alt + F7”。</p>
<hr>
<h2 id="10-“Ctrl-Alt-F7”、“Alt-F7”"><a href="#10-“Ctrl-Alt-F7”、“Alt-F7”" class="headerlink" title="10.“Ctrl + Alt + F7”、“Alt + F7”"></a>10.“Ctrl + Alt + F7”、“Alt + F7”</h2><p>使用“Shift,Shift”找到我们的“Commons.kt”文件，我们用“Ctrl + F12”，把光标移动到“logMe”这个方法名字上，然后“Ctrl + Alt + F7”，就能得到和“Ctrl+点击鼠标左键”一样的功能咯。当然还有一个快捷键就是“Alt + F7”，不过这个不是以弹出窗的形式，而是打开[3:Find]模块窗口，这个窗口在我们使用“Ctrl + Shift + R”全局字符串替换 或者“Ctrl + Shift + F”全局字符串搜索的时候也会使用到。</p>
<p>假设现在我们已经从源码中的得到了我们想要的知识了，正式进入开发阶段，为了开发方便，我现在想引入一个Kotlin官方提供的<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">anko</a>裤，于是使用“Shift,Shift”找到我们module的“build.gradle”文件，拷贝对应的字符串：</p>
<pre><code>compile &quot;org.jetbrains.anko:anko:$anko_version&quot;
</code></pre><p>使用“Ctrl + F”，输入“depende”定位到dependencies的DSL块(在gradle中还不支持“Ctrl + F12”)，使用上文提过的“Ctrl + ]”定位到末尾的花括号“}”，在使用上文提过的“Ctrl + Alt + 回车”向上插入一行，然后粘贴即可。还是那句话，描述虽长，熟练操作后是瞬间的事，这里不去比较使用鼠标是否更好，本文只专注介绍快捷键。</p>
<p>因为我们修改了gradle文件，所以“Sync Now”那条黄色背景的提示会出现tabs的下面，我们可以移动鼠标去点击，然而我这里又告诉你，没有快捷键，当然成熟的IDE怎么可能就此妥协，于巨给个“定制快捷键功能”。</p>
<hr>
<h2 id="11-定制“Gradle-Sync”快捷键，个人推荐“Alt-C-Alt-C”"><a href="#11-定制“Gradle-Sync”快捷键，个人推荐“Alt-C-Alt-C”" class="headerlink" title="11.定制“Gradle Sync”快捷键，个人推荐“Alt + C,Alt + C”"></a>11.定制“Gradle Sync”快捷键，个人推荐“Alt + C,Alt + C”</h2><p>打开设置，直接上图，一目了然。</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic9.png" alt="图9"></p>
<p>个人推荐设置成连续按两次“Alt + C”，也就是“Alt + C,Alt + C”。按“Esc”关闭设置，然后“Alt + C,Alt + C”，发现“Gradle Sync”执行了。</p>
<p>这时候我们想要将这个gralde的tab关闭，我们可能会点击tab的×，或者之间在tab上点击中键，但是其实我们可以省略了手从键盘移动到鼠标上的步骤，而直接在键盘上操作。</p>
<hr>
<h2 id="12-关闭tab，关闭其他tabs"><a href="#12-关闭tab，关闭其他tabs" class="headerlink" title="12.关闭tab，关闭其他tabs"></a>12.关闭tab，关闭其他tabs</h2><p>因为默认的关闭tab的快捷键还涉及到要按“F4”的组合，我觉得操作起来不太方便，而且开关tab是个很常用的操作，因此我个人推荐设置成“Ctrl  + Shift + Q”，原因如下：原来我还以为这个关闭tab的快捷键会和Chrome浏览器一样是“Ctrl + W”，结果发现AS的“Ctrl + W”是另一个很好用的功能，那就是扩展选中，为了避免冲突，再三考虑之后“close tab”就设置成“Ctrl  + Shift + Q”了，于是“close others”就设置成“Alt + Shift + Q”了。和在Settings的keymap中搜索“tab”，还能找到其他的快捷键，读者可自行查看。</p>
<p>上面提到了“Ctrl + W”，用法的例子如下：</p>
<p>比如现在有一个字符串“Halohoop”，光标停在了“Ha”之后“lohoop”之前，“Ha↑lohoop”，如果我们要选中这个单词可以直接按“Ctrl + W”，读者实操一下就能上手了，还可以试一下多按几次“Ctrl + W”看看有什么效果。</p>
<p>好了，回到场景中，现在我想要挨个过一下打开的tabs，以决定要不要关闭它，于巨给个“Alt + 左或右”。</p>
<hr>
<h2 id="13-“Alt-左或右”"><a href="#13-“Alt-左或右”" class="headerlink" title="13.“Alt + 左或右”"></a>13.“Alt + 左或右”</h2><p>我们切换tab不需要鼠标去点，“Alt + 左或右”即可。这个快捷键不仅在Editoer窗口中可以使用，在[1:Project](“Alt + 1”)或者[6:Android Monitor](“Alt + 6”)也可以使用。</p>
<p>文章到尾声了，还有一些有用的快捷键我就不套用情景去说了，在这里直接提一下。</p>
<hr>
<h2 id="14-“Ctrl-上或下”，“Ctrl-Alt-Shift-左或右”，滚动编辑区域的单行或者单字母"><a href="#14-“Ctrl-上或下”，“Ctrl-Alt-Shift-左或右”，滚动编辑区域的单行或者单字母" class="headerlink" title="14.“Ctrl + 上或下”，“Ctrl + Alt + Shift + 左或右”，滚动编辑区域的单行或者单字母"></a>14.“Ctrl + 上或下”，“Ctrl + Alt + Shift + 左或右”，滚动编辑区域的单行或者单字母</h2><p>有时候我们使用鼠标滚轮可能不能很好的精确控制滚到某一行，所以可以使用滚轮，滚到附近的时候再使用“Ctrl + 上或下”。<br>左右的滚动也是，拖动可能不能很好的精确控制滚到某一列，使用“Ctrl + Alt + Shift + 左或右”。</p>
<hr>
<h2 id="15-Shift-F6，关联重命名，不用解释。"><a href="#15-Shift-F6，关联重命名，不用解释。" class="headerlink" title="15.Shift + F6，关联重命名，不用解释。"></a>15.Shift + F6，关联重命名，不用解释。</h2><hr>
<h2 id="16-Alt-F12-打开-关闭终端Terminal"><a href="#16-Alt-F12-打开-关闭终端Terminal" class="headerlink" title="16.Alt + F12 打开/关闭终端Terminal"></a>16.Alt + F12 打开/关闭终端Terminal</h2><hr>
<h2 id="17-知道快捷键，但是想查找功能的名字"><a href="#17-知道快捷键，但是想查找功能的名字" class="headerlink" title="17.知道快捷键，但是想查找功能的名字"></a>17.知道快捷键，但是想查找功能的名字</h2><p><img src="/2017/07/16/snacks_shortcuts_of_as/pic10.png" alt="图10"></p>
<hr>
<h2 id="18-鼠标中键滚轮按着不放可以垂直选中"><a href="#18-鼠标中键滚轮按着不放可以垂直选中" class="headerlink" title="18.鼠标中键滚轮按着不放可以垂直选中"></a>18.鼠标中键滚轮按着不放可以垂直选中</h2><p><img src="/2017/07/16/snacks_shortcuts_of_as/pic11.gif" alt="图11"></p>
<p>这个功能“Sublime”也有。其实和第8节中上中提到的多光标功能应该属于一套。</p>
<hr>
<h2 id="19-导出设置"><a href="#19-导出设置" class="headerlink" title="19.导出设置"></a>19.导出设置</h2><p><img src="/2017/07/16/snacks_shortcuts_of_as/pic12.png" alt="图12"></p>
<p>换电脑或者重装系统的时候记得导出设置，这样自定义的快捷键就不会丢失了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为AS基于IntelliJ IDAE，所以以上快捷键也基本适用于IntelliJ IDAE的其他变种，如WebStorm、PyCharm等。</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic13.png" alt="图13"></p>
<p>当然鼠标也是很重要很重要的，我们的眼神已经习惯跟着鼠标来回移动，鼠标能够帮我们更加集中我们的目光和注意力，也是必不可少的，毕竟不可能只用到IDE而已，IDE以外的软件不可能全部离开鼠标，而且IDE中所有功能也并非使用键盘就能全部完成了，比如说精确调整[6:Android Monitor](“Alt + 6”)的高度，虽然也有快捷键，但是是按单位高度调整的。</p>
<p><img src="/2017/07/16/snacks_shortcuts_of_as/pic14.png" alt="图14"></p>
<p>记录这篇文章的目的，一是希望真的能够帮助到彼此提高效率，二是想好好玩味一下IDE的设计者为开发者到底能考虑到多么方便的程度，我想现在我内心应该已经有了答案了。</p>
<p>如果以后还有什么更好用的快捷键功能我也会更新到这篇博文的。</p>
<h3 id="1-文章提到的快捷键预览表"><a href="#1-文章提到的快捷键预览表" class="headerlink" title="1.文章提到的快捷键预览表"></a>1.文章提到的快捷键预览表</h3><p>这里我不写作用，看看用以回顾，看看能反应出来多少个.</p>
<ul>
<li>1.Alt + F1,1</li>
<li>2.Alt + F1,0</li>
<li>3.Alt + F1,8</li>
<li>4.Esc</li>
<li>5.Ctrl + 左或右</li>
<li>6.Ctrl + [ 或 ]</li>
<li>7.Shift + 上下左右</li>
<li>8.Ctrl + Shift + [ 或 ]</li>
<li>9.Ctrl + Shift + 左或右</li>
<li>10.F4</li>
<li>11.Ctrl + Alt + 左或右</li>
<li>12.Ctrl + Shift + A</li>
<li>13.Alt + Enter</li>
<li>14.Ctrl + Shift + 回车</li>
<li>15.Ctrl + 回车</li>
<li>16.Ctrl + Alt + 回车</li>
<li>17.Shift + 回车</li>
<li>18.Alt + Shift不放开，鼠标点击其他位置</li>
<li>19.Alt + 上下</li>
<li>20.Ctrl + F12</li>
<li>21.Ctrl + F11</li>
<li>22.F11</li>
<li>23.Shift + F11</li>
<li>24.Ctrl + Alt + F7</li>
<li>25.Alt + F7</li>
<li>26.Ctrl + Shift + R</li>
<li>27.Ctrl + Shift + F</li>
<li>28.Ctrl + F</li>
<li>29.Gradle Sync</li>
<li>30.关闭tab，关闭其他tabs</li>
<li>31.Ctrl + W</li>
<li>32.Alt + 左或右</li>
<li>33.Ctrl + 上或下</li>
<li>34.Ctrl + Alt + Shift + 左或右</li>
<li>35.Shift + F6</li>
<li>36.鼠标中键滚轮按着不放</li>
</ul>
<h3 id="2-找快捷键："><a href="#2-找快捷键：" class="headerlink" title="2.找快捷键："></a>2.找快捷键：</h3><ul>
<li>1.Settings的Keymap中搜索关键字；</li>
<li>2.“Ctrl + Shift + A”搜索关键字；</li>
<li>2.鼠标悬停的提示中；</li>
<li>3.右键菜单中；</li>
</ul>
<h3 id="3-其他的提效方式——手势"><a href="#3-其他的提效方式——手势" class="headerlink" title="3.其他的提效方式——手势"></a>3.其他的提效方式——手势</h3><p>如开头提到的，快捷键和手势都是一种提效方式，接下来也提一下手势。<br>其实，不仅仅是手机，在MAC，PC，浏览器，无不例外的出现了Gesture插件。</p>
<p>因为这不是本文重点，所以这里我只列举一些我自己平常在PC端用到软件或插件：</p>
<h4 id="3-1-PC-端：StrokeIt。"><a href="#3-1-PC-端：StrokeIt。" class="headerlink" title="3.1.PC 端：StrokeIt。"></a>3.1.PC 端：StrokeIt。</h4><p><img src="/2017/07/16/snacks_shortcuts_of_as/pic15.png" alt="图15"></p>
<p>这个真的很好用，还是开源的软件，一年前，为了表示支持，我还把我PayPal赚到的10多美元全部Donate给他了。<br>地址：<a href="http://www.tcbmi.com/strokeit/" target="_blank" rel="external">http://www.tcbmi.com/strokeit/</a></p>
<h4 id="3-2-热键小工具-myhotkey"><a href="#3-2-热键小工具-myhotkey" class="headerlink" title="3.2.热键小工具(myhotkey)"></a>3.2.热键小工具(myhotkey)</h4><pre><code>* [热键助手 v4.6.0 正式版](http://www.crsky.com/soft/2159.html)
* 支持设置热键打开各种软件、文件、文件夹，告别混乱的桌面快捷方式。 
</code></pre><h4 id="3-3-FireFox："><a href="#3-3-FireFox：" class="headerlink" title="3.3.FireFox："></a>3.3.FireFox：</h4><p><img src="/2017/07/16/snacks_shortcuts_of_as/pic16.png" alt="图16"></p>
<h4 id="3-4-Chrome："><a href="#3-4-Chrome：" class="headerlink" title="3.4.Chrome："></a>3.4.Chrome：</h4><p><img src="/2017/07/16/snacks_shortcuts_of_as/pic17.png" alt="图17"></p>
<h4 id="3-5-MAC"><a href="#3-5-MAC" class="headerlink" title="3.5.MAC"></a>3.5.MAC</h4><p>MAC显然是天生自带这些插件的功能的，天生丽质，对于我这种一个月只有几十毛捡破烂钱收入的人来说只能是一笑而过，诶。</p>
<hr>
<p>最后，总而言之，言而总之（知难而退，退避三舍，舍近求远，远走高飞，飞檐走壁去去就来…突然很想成语接龙），快捷键就像女友，一直都在那里，只是你不去找而已，当然，像我这种颜值负数的人来说就另当别论了。</p>
<p>最最后，自强，共勉，卖牙膏霸气侧漏农村有文化的芖口钉 敬上。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;1997 - 2020 By Halohoop</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>